<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="icon" href="/gochat.ico" type="image/x-icon">
  <title>ğŸ’¬ å®æ—¶èŠå¤©</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f0f2f5;
    }
    /* å³ä¸Šè§’è®¾ç½®æŒ‰é’® */
    #settingsBtn { position: fixed; top: 12px; right: 12px; z-index: 20; background: #fff; border: 1px solid #ddd; border-radius: 50%; width: 40px; height: 40px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); cursor: pointer; display: flex; align-items: center; justify-content: center; }
    #settingsBtn:hover { background: #f7f7f7; }
    /* è®¾ç½®å¼¹çª— */
    #settingsModal { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; align-items: center; justify-content: center; z-index: 30; }
    #settingsModal .panel { background: #fff; width: 520px; max-width: calc(100% - 40px); border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); overflow: hidden; }
    #settingsModal .panel .hd { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #eee; font-weight: 600; }
    #settingsModal .panel .bd { padding: 16px; max-height: 70vh; overflow: auto; }
    .test-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .test-grid button { padding: 10px 12px; border-radius: 8px; border: 1px solid #ddd; background: #fafafa; color: #333; cursor: pointer; }
    .test-grid button:hover { background: #f0f0f0; }
    #settingsModal .panel { color:#333; }
    #settingsModal .panel .hd { color:#333; }
    .muted { color:#999; font-size: 12px; }

    .progress {
      height: 6px;
      background: rgba(0,0,0,0.1);
      border-radius: 3px;
      overflow: hidden;
      margin-top: 6px;
    }
    .progress > .bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #4caf50, #81c784);
      transition: width 0.1s ease;
    }
    .actions-row { display:flex; gap:8px; align-items:center; margin-top:6px; }
    .small { font-size:12px; color:#666; }
    .muted { color:#999; }
    .btn-sm { padding:6px 10px; border-radius:12px; font-size:12px; }
    .disabled { opacity:0.5; pointer-events:none; }
    #container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-width: 1000px;
      margin: 0 auto;
      width: 100%;
      padding: 16px;
    }
    h1 {
      text-align: center;
      margin-bottom: 12px;
      color: #333;
      font-size: 1.4em;
    }
    #chatBox {
      flex: 1;
      overflow-y: auto;
      background: white;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
    }
    .message {
      max-width: 80%;
      margin-bottom: 16px;
      position: relative;
    }
    .system {
      color: #888;
      font-style: italic;
      text-align: center;
      font-size: 0.9em;
      align-self: center;
      margin-top: 8px;
      margin-bottom: 8px;
    }

    /* è‡ªå·±çš„æ¶ˆæ¯ï¼šé å³ */
    .self {
      align-self: flex-end;
      text-align: right;
    }
    .self .bubble {
      background: #0084ff;
      color: white;
      border-radius: 18px 18px 4px 18px;
    }

    /* ä»–äººæ¶ˆæ¯ï¼šé å·¦ */
    .other {
      align-self: flex-start;
      text-align: left;
    }
    .other .bubble {
      background: #e5e5ea;
      color: black;
      border-radius: 18px 18px 18px 4px;
    }

    .bubble {
      padding: 12px 16px;
      word-wrap: break-word;
      white-space: pre-wrap; /* ä¿ç•™æ¢è¡Œä½†ä¸å¼ºåˆ¶æ¯ä¸ªå­—æ¢è¡Œ */
      line-height: 1.4;
      display: inline-block;
      max-width: 100%;
    }

    .header {
      font-size: 0.8em;
      margin-bottom: 4px;
      font-weight: bold;
    }
    .self .header {
      color: #a0d4ff;
      text-align: right;
    }
    .other .header {
      color: #666;
      text-align: left;
    }

    .time {
      font-size: 0.7em;
      color: #999;
      margin-top: 4px;
      text-align: right;
    }

    #inputArea {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    #messageInput {
      flex: 1;
      padding: 12px 16px;
      border: 1px solid #ccc;
      border-radius: 24px;
      outline: none;
      font-size: 16px;
      min-height: 20px;
    }
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 24px;
      background: #0084ff;
      color: white;
      cursor: pointer;
      font-size: 16px;
      white-space: nowrap;
    }
    button:hover {
      opacity: 0.9;
    }
    #uploadBtn {
      background: #4caf50;
    }
    #fileInput {
      display: none;
    }
  </style>
</head>
<body>
  <div id="container">
    <button id="settingsBtn" title="è®¾ç½®ä¸æµ‹è¯•" aria-label="è®¾ç½®">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9c0 .66.26 1.3.73 1.77.47.47 1.11.73 1.77.73H21a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
      </svg>
    </button>
    <div id="settingsModal">
      <div class="panel">
        <div class="hd">
          <span>è®¾ç½®ä¸æµ‹è¯•</span>
          <button id="settingsClose" class="btn-sm">å…³é—­</button>
        </div>
        <div class="bd">
          <div class="muted" style="margin-bottom:8px;">å¿«é€Ÿæµ‹è¯•å¸¸ç”¨æ¥å£ä¸é€šé“</div>
          <div style="margin-bottom:10px; display:flex; align-items:center; gap:8px;">
            <input type="checkbox" id="lanModeSwitch" />
            <label for="lanModeSwitch">å¯ç”¨ LAN ä¼˜åŒ–æ¨¡å¼ï¼ˆä»…ä½¿ç”¨æœ¬åœ°å±€åŸŸç½‘å€™é€‰ï¼Œè·³è¿‡å…¬ç½‘ STUNï¼‰</label>
          </div>
          <div class="test-grid">
            <button id="testSendText">å‘é€æ–‡æœ¬(Hello)</button>
            <button id="testWS">æµ‹è¯• WebSocket</button>
            <button id="testP2PPlaceholder">ç¾¤å‘å ä½(P2P)</button>
            <button id="testFilesList">è·å–æ–‡ä»¶åˆ—è¡¨</button>
            <button id="testUploadSmall">ä¸Šä¼ å°æ–‡ä»¶</button>
            <button id="testSignal">å‘é€ä¿¡ä»¤(ping)</button>
          </div>
        </div>
      </div>
    </div>

    <h1>ğŸ’¬ å±€åŸŸç½‘ä¸´æ—¶æµ‹è¯•æ”¶å‘ä¿¡æ¯å’Œæ–‡ä»¶</h1>
    <div id="chatBox"></div>
    <div id="inputArea">
      <input type="text" id="messageInput" placeholder="è¾“å…¥æ¶ˆæ¯..." autocomplete="off" />
      <button id="sendBtn">å‘é€</button>

      <input type="file" id="fileInput" style="display:none" />
      <input type="file" id="fileInputServer" style="display:none" />
      <input type="file" id="fileInputDirect" style="display:none" />

      <button id="fileSendBtn">ğŸ“ æ–‡ä»¶å‘é€</button>
    </div>

    <!-- æ–‡ä»¶å‘é€é€‰é¡¹èœå• -->
    <div id="fileSendMenu" style="display:none; position:absolute; right:16px; bottom:80px; background:#fff; border:1px solid #ddd; border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,0.12); padding:12px; min-width:260px; z-index:10;">
      <div style="font-weight:600; margin-bottom:8px;">é€‰æ‹©å‘é€æ–¹å¼</div>
      <label style="display:block; margin:6px 0;">
        <input type="radio" name="sendMode" value="p2p" checked /> P2P ç¾¤é‡Œå ä½ï¼Œç‚¹å‡»åå†ä¼ 
      </label>
      <label style="display:block; margin:6px 0;">
        <input type="radio" name="sendMode" value="direct" /> ç›´ä¼ ç»™é€‰ä¸­ç”¨æˆ·
      </label>
      <div id="menuTargetWrap" style="margin-left:18px; margin-top:4px; display:none;">
        <select id="menuTargetUser" style="padding:6px 8px; border-radius:6px; border:1px solid #ccc; min-width:160px">
          <option value="">è¯·é€‰æ‹©ç”¨æˆ·</option>
        </select>
      </div>
      <label style="display:block; margin:6px 0;">
        <input type="radio" name="sendMode" value="server" /> ä¸Šä¼ åˆ°æœåŠ¡å™¨å¹¶ç¾¤å‘é“¾æ¥
      </label>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px;">
        <button id="menuCancel" class="btn-sm" style="background:#eee;color:#333;">å–æ¶ˆ</button>
        <button id="menuConfirm" class="btn-sm" style="background:#0084ff; color:#fff;">ç¡®å®š</button>
      </div>
    </div>
  </div>

  <script>
    const serviceUrl = window.location.host;
    let myUserId = '';
    let ws = null;
    let peerConnections = {}; // userId -> RTCPeerConnection
    let dataChannels = {};    // userId -> RTCDataChannel
    let onlineUsers = [];     // åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ï¼ˆæ¥è‡ªæœåŠ¡ç«¯å¹¿æ’­ï¼‰

    function connectWebSocket() {
      ws = new WebSocket(`ws://${serviceUrl}/ws`);

      ws.onopen = () => {
        console.log('[ws] open');
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'init') {
          myUserId = data.userId;
          console.log('[ws:init] myUserId', myUserId);
        } else if (data.type === 'message') {
          addMessageToUI(data.data);
        } else if (data.type === 'users') {
          // ç³»ç»Ÿå¹¿æ’­åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ï¼ˆé€—å·åˆ†éš”ï¼‰
          onlineUsers = data.data.text ? data.data.text.split(',').filter(u => u && u !== myUserId) : [];
          console.log('[ws:users]', onlineUsers);
          refreshTargetUser();
        } else if (data.type === 'signal') {
          // æ”¶åˆ°æ¥è‡ªæœåŠ¡ç«¯è½¬å‘çš„ä¿¡ä»¤
          const s = data.data; // { type, from, to, payload }
          handleSignalFromPeer(s);
        }
      };

      ws.onclose = () => {
        console.warn('[ws] close, reconnect in 5s');
        setTimeout(connectWebSocket, 5000);
      };

      ws.onerror = (err) => {
        console.error('[ws] error', err);
      };
    }

    let lanMode = true; // å±€åŸŸç½‘ç›´è¿æ¨¡å¼ï¼Œä¼˜å…ˆç”¨æœ¬åœ°å€™é€‰ï¼Œç»•è¿‡å…¬ç½‘ STUN
    async function createConnection(toUserId) {
      if (peerConnections[toUserId]) { console.log('[pc] reuse', toUserId); return peerConnections[toUserId]; }
      console.log('[pc] create', toUserId, 'lanMode=', lanMode);
      const config = lanMode
        ? { iceServers: [], bundlePolicy: 'max-bundle' }
        : { iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }], bundlePolicy: 'max-bundle' };
      const pc = new RTCPeerConnection(config);

      pc.onicecandidate = (e) => {
        if (e.candidate) {
          const candStr = e.candidate.candidate || '';
          const isHost = /\btyp host\b/.test(candStr);
          const type = (candStr.match(/\btyp (host|srflx|relay)\b/)||[])[1] || 'unknown';
          console.log('[ice:cand:local]', toUserId, type, candStr);
          if (!lanMode || isHost) {
            sendSignal({ type: 'candidate', to: toUserId, payload: { candidate: e.candidate } });
          } else {
            console.log('[ice:cand:drop]', 'non-host in LAN mode');
          }
        }
      };

      pc.ondatachannel = (event) => {
        const channel = event.channel;
        console.log('[pc:ondatachannel]', toUserId, channel.label);
        registerDataChannel(toUserId, channel);
      };
      pc.oniceconnectionstatechange = () => { console.log('[pc:ice]', toUserId, pc.iceConnectionState); };
      pc.onconnectionstatechange = () => { console.log('[pc:state]', toUserId, pc.connectionState); };

      peerConnections[toUserId] = pc;
      return pc;
    }

    async function waitForChannelOpen(channel, timeout = 15000) {
      if (!channel) throw new Error('DataChannel missing');
      if (channel.readyState === 'open') return;
      console.log('[dc] wait open...', channel.readyState);
      await new Promise((resolve, reject) => {
        const start = Date.now();
        const onOpen = () => { cleanup(); resolve(); };
        const check = () => {
          if (channel.readyState === 'open') { cleanup(); resolve(); return; }
          if (channel.readyState === 'closing' || channel.readyState === 'closed') { cleanup(); reject(new Error('DataChannel closed before open')); return; }
          if (Date.now() - start > timeout) { cleanup(); reject(new Error('DataChannel open timeout')); return; }
          setTimeout(check, 50);
        };
        const cleanup = () => { channel.removeEventListener('open', onOpen); };
        channel.addEventListener('open', onOpen);
        check();
      });
      console.log('[dc] opened');
    }

    async function waitForIceConnected(pc, timeout = 15000) {
      if (!pc) throw new Error('PeerConnection missing');
      const ok = s => s === 'connected' || s === 'completed';
      if (ok(pc.iceConnectionState)) return;
      console.log('[ice] wait...', pc.iceConnectionState);
      await new Promise((resolve, reject) => {
        const start = Date.now();
        const onChange = () => {
          const s = pc.iceConnectionState;
          console.log('[ice] state', s);
          if (ok(s)) { cleanup(); resolve(); }
          else if (['failed','disconnected','closed'].includes(s)) { cleanup(); reject(new Error('ICE ' + s)); }
        };
        const timer = setInterval(() => {
          if (ok(pc.iceConnectionState)) { cleanup(); resolve(); }
          else if (Date.now() - start > timeout) { cleanup(); reject(new Error('ICE timeout')); }
        }, 200);
        const cleanup = () => { clearInterval(timer); pc.removeEventListener('iceconnectionstatechange', onChange); };
        pc.addEventListener('iceconnectionstatechange', onChange);
      });
      console.log('[ice] connected');
    }

    function registerDataChannel(toUserId, channel) {
      dataChannels[toUserId] = channel;
      channel.onopen = () => { console.log('[dc] open', toUserId); };
      channel.onclose = () => { console.log('[dc] close', toUserId); };
      channel.onerror = (e) => { console.error('[dc] error', toUserId, e); };

      let receiving = { name: '', size: 0, mime: 'application/octet-stream', chunks: [], received: 0 };

      channel.binaryType = 'arraybuffer';
      channel.onmessage = async (e) => { console.log('[DC:onmessage]', toUserId, typeof e.data);
        if (typeof e.data === 'string') {
          try {
            const msg = JSON.parse(e.data);
            if (msg.type === 'text') {
              addMessageToUI({ text: msg.text, from: toUserId, time: new Date().toLocaleTimeString() });
            } else if (msg.type === 'file-meta') {
              receiving = { name: msg.name, size: msg.size, mime: msg.mime || 'application/octet-stream', chunks: [], received: 0 };
            } else if (msg.type === 'file-end') {
              const blob = new Blob(receiving.chunks, { type: receiving.mime });
              const url = URL.createObjectURL(blob);
              const ext = receiving.name.split('.').pop()?.toLowerCase() || '';
              const isImage = ['jpg','jpeg','png','gif','webp','bmp'].includes(ext);
              const node = isImage
                ? (() => { const img = document.createElement('img'); img.src = url; img.alt = receiving.name; img.style.maxWidth = '100%'; img.style.borderRadius = '8px'; img.style.marginTop = '6px'; img.onclick = () => window.open(url, '_blank'); return img; })()
                : (() => { const a = document.createElement('a'); a.href = url; a.download = receiving.name; a.textContent = `ğŸ“ ${receiving.name} (${(receiving.size/1024).toFixed(1)} KB)`; return a; })();
              addMessageToUI({ from: toUserId, time: new Date().toLocaleTimeString(), contentNode: node });
              console.log('[recv:file-end]', { from: toUserId, name: receiving.name });
              receiving = { name: '', size: 0, mime: 'application/octet-stream', chunks: [], received: 0 };
            } else if (msg.type === 'file-meta') {
              console.log('[recv:file-meta]', { from: toUserId, name: msg.name, size: msg.size });
              // æ¥æ”¶ç«¯æ˜¾ç¤ºè¿›åº¦æ¡ï¼ˆæ˜¾ç¤ºå‘é€è€…ï¼‰
              const container = document.createElement('div');
              container.className = 'message other';
              const prog = ensureProgress(container, `recv-${toUserId}-${msg.name}`, `æ¥è‡ª ${toUserId}ï¼š${msg.name}`);
              document.getElementById('chatBox').appendChild(container);
            } else if (msg.type === 'p2p-file-request') {
              // åªæœ‰å‘é€è€…ä¼šå¤„ç†è¯¥è¯·æ±‚ï¼šæŸ¥æ‰¾æœ¬åœ° pendingFilesï¼Œå¯åŠ¨åˆ†ç‰‡å‘é€ï¼Œå¸¦è¿›åº¦
              const fileId = msg.fileId;
              console.log('[p2p-file-request] from', toUserId, fileId);
              const file = window.pendingFiles ? window.pendingFiles[fileId] : null;
              if (!file) { console.warn('[p2p] file not found in sender cache', fileId); return; }
              // åœ¨è‡ªå·±çš„æ¶ˆæ¯åŒºæ˜¾ç¤ºè¿›åº¦æ¡ï¼ˆæ˜¾ç¤ºç›®æ ‡ç”¨æˆ·ï¼‰
              const container = document.createElement('div');
              container.className = 'message self';
              const prog = ensureProgress(container, `send-${toUserId}-${fileId}`, `å‘é€ç»™ ${toUserId}ï¼š${file.name}`);
              document.getElementById('chatBox').appendChild(container);
              // ç­‰å¾… ICE ä¸é€šé“æ‰“å¼€å†å‘é€
              await waitForIceConnected(peerConnections[toUserId]).catch(e => { console.warn('[ice] not ready', e); });
              await waitForChannelOpen(channel);
              console.log('[send:file-meta]', { to: toUserId, name: file.name, size: file.size });
              // å‘é€å…ƒä¿¡æ¯ï¼ˆå†æ¬¡æ ¡éªŒé€šé“çŠ¶æ€ï¼‰
              if (channel.readyState !== 'open') { throw new Error('DataChannel not open before meta'); }
              try { channel.send(JSON.stringify({ type: 'file-meta', name: file.name, size: file.size, mime: file.type || 'application/octet-stream' })); }
              catch (e) { throw new Error('send meta failed: ' + e.message); }
              // åˆ†ç‰‡+é˜ˆå€¼é™æµï¼ˆå°åˆ†ç‰‡ + bufferedamountlowï¼‰
              const reader = file.stream().getReader();
              let sent = 0; let canceled = false;
              const onClose = () => { canceled = true; prog.info.textContent = `è¿æ¥å·²å…³é—­ï¼š${file.name}`; };
              channel.addEventListener('close', onClose);
              prog.cancelBtn.onclick = () => { canceled = true; try { reader.cancel(); } catch {} prog.info.textContent = `å·²å–æ¶ˆï¼š${file.name}`; prog.meta && (prog.meta.textContent=''); };
              const SLICE = 64 * 1024; // 64KB å°åˆ†ç‰‡
              channel.bufferedAmountLowThreshold = 256 * 1024; // 256KB ä½æ°´ä½
              const waitBufferedLow = async () => {
                if (channel.bufferedAmount <= channel.bufferedAmountLowThreshold) return;
                await new Promise(resolve => {
                  const h = () => { channel.removeEventListener('bufferedamountlow', h); resolve(); };
                  channel.addEventListener('bufferedamountlow', h);
                });
              };
              try {
                let lastT = Date.now(), lastB = 0;
                while (true) {
                  const { done, value } = await reader.read();
                  if (done || canceled) break;
                  if (channel.readyState !== 'open') { throw new Error('DataChannel not open during send'); }
                  const chunkView = value instanceof Uint8Array ? value : new Uint8Array(value);
                  for (let off = 0; off < chunkView.byteLength; off += SLICE) {
                    if (canceled) break;
                    if (channel.readyState !== 'open') { throw new Error('DataChannel not open during send'); }
                    const piece = chunkView.subarray(off, Math.min(off + SLICE, chunkView.byteLength));
                    await waitBufferedLow();
                    channel.send(piece);
                    sent += piece.byteLength;
                    const now = Date.now();
                    if (now - lastT >= 500) {
                      const db = sent - lastB; const dt = (now - lastT)/1000;
                      const speed = db/dt; const remain = Math.max(0, file.size - sent);
                      const eta = speed>0 ? remain/speed : 0;
                      prog.meta && (prog.meta.textContent = `${(speed/1024).toFixed(1)} KB/sï¼Œå‰©ä½™çº¦ ${eta.toFixed(1)} s`);
                      lastT = now; lastB = sent;
                    }
                    const pct = Math.min(100, Math.round((sent / file.size) * 100));
                    prog.bar.style.width = pct + '%';
                    if (sent % (512*1024) < SLICE) console.log('[send:progress]', toUserId, pct + '%');
                  }
                }
                if (!canceled) {
                  await waitBufferedLow();
                  channel.send(JSON.stringify({ type: 'file-end' }));
                  console.log('[send:file-end]', { to: toUserId, fileId });
                  prog.info.textContent = `å‘é€ç»™ ${toUserId}ï¼š${file.name}ï¼ˆå®Œæˆï¼‰`;
                  prog.bar.style.width = '100%';
                }
              } catch (err) {
                console.error('[p2p:send:error]', err);
                alert('P2P å‘é€å¤±è´¥ï¼š' + err.message);
              }
            }
          } catch {}
        } else {
          receiving.chunks.push(e.data);
          receiving.received += e.data.byteLength || 0;
          if (receiving.received % (512*1024) < 65536) console.log('[recv:progress]', toUserId, Math.round((receiving.received/receiving.size)*100)+'%');
          const key = `recv-${toUserId}-${receiving.name}`;
          if (progressMap[key]) {
            const pct = receiving.size ? Math.min(100, Math.round((receiving.received / receiving.size) * 100)) : 0;
            progressMap[key].bar.style.width = pct + '%';
          }
        }
      };
    }

    async function sendSignal(s) {
      if (!ws || ws.readyState !== WebSocket.OPEN) { console.warn('[signal] ws not open'); return; }
      const payload = { type: 'signal', data: { ...s, from: myUserId } };
      console.log('[signal:send]', payload);
      ws.send(JSON.stringify(payload));
    }

    async function connectToUser(toUserId) {
      console.log('[connect] to', toUserId);
      const pc = await createConnection(toUserId);
      const channel = pc.createDataChannel('chat');
      console.log('[dc:create]', toUserId, channel.label);
      registerDataChannel(toUserId, channel);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      sendSignal({ type: 'offer', to: toUserId, payload: { sdp: offer } });
    }

    async function handleSignalFromPeer(s) {
      const { type, from, payload } = s;
      console.log('[signal:recv]', type, 'from', from);
      const pc = await createConnection(from);
      if (type === 'offer') {
        await pc.setRemoteDescription(payload.sdp);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        sendSignal({ type: 'answer', to: from, payload: { sdp: answer } });
      } else if (type === 'answer') {
        await pc.setRemoteDescription(payload.sdp);
      } else if (type === 'candidate') {
        try { await pc.addIceCandidate(payload.candidate); } catch (e) { console.error(e); }
      }
    }

    const progressMap = {};

    function ensureProgress(div, key, label) {
      if (!progressMap[key]) {
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        const info = document.createElement('div');
        info.textContent = label;
        const meta = document.createElement('div');
        meta.className = 'small muted';
        meta.textContent = '';
        const progress = document.createElement('div');
        progress.className = 'progress';
        const bar = document.createElement('div');
        bar.className = 'bar';
        progress.appendChild(bar);
        const actions = document.createElement('div');
        actions.className = 'actions-row';
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'btn-sm';
        cancelBtn.textContent = 'å–æ¶ˆ';
        actions.appendChild(cancelBtn);
        bubble.appendChild(info);
        bubble.appendChild(meta);
        bubble.appendChild(progress);
        bubble.appendChild(actions);
        div.appendChild(bubble);
        progressMap[key] = { bar, info, meta, container: bubble, cancelBtn };
      }
      return progressMap[key];
    }

    function addMessageToUI(msg) {
      const chatBox = document.getElementById('chatBox');

      if (msg.from === 'system') {
        const div = document.createElement('div');
        div.className = 'message system';
        div.textContent = msg.text;
        chatBox.appendChild(div);
        chatBox.scrollTop = chatBox.scrollHeight;
        return;
      }

      const isSelf = msg.from === myUserId;
      const div = document.createElement('div');
      div.className = isSelf ? 'message self' : 'message other';

      // è‹¥æä¾›ç›´æ¥çš„å†…å®¹èŠ‚ç‚¹ï¼ˆç”¨äº P2P æ–‡ä»¶å±•ç¤ºï¼‰
      if (msg.contentNode) {
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        bubble.appendChild(msg.contentNode);
        const header = document.createElement('div');
        header.className = 'header';
        header.textContent = msg.from;
        const timeEl = document.createElement('div');
        timeEl.className = 'time';
        timeEl.textContent = msg.time;
        div.appendChild(header);
        div.appendChild(bubble);
        div.appendChild(timeEl);
        chatBox.appendChild(div);
        chatBox.scrollTop = chatBox.scrollHeight;
        return;
      }

      // å°è¯•è§£ææ˜¯å¦ä¸ºæœåŠ¡å™¨æ–‡ä»¶æ¶ˆæ¯ æˆ– P2På ä½æ¶ˆæ¯
      let content;
      let isFile = false;
      try {
        const parsed = JSON.parse(msg.text);
        if (parsed && parsed.type === 'file') {
          isFile = true;
          const { url, name, size } = parsed;
          const ext = name.split('.').pop()?.toLowerCase() || '';

          const formatSize = (bytes) => {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
          };

          if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'].includes(ext)) {
            const img = document.createElement('img');
            img.src = `http://${serviceUrl}${url}`;
            img.alt = name;
            img.style.maxWidth = '100%';
            img.style.borderRadius = '8px';
            img.style.marginTop = '6px';
            img.style.cursor = 'pointer';
            img.onclick = () => window.open(img.src, '_blank');
            content = img;
          } else {
            const link = document.createElement('a');
            link.href = `http://${serviceUrl}${url}`;
            link.target = '_blank';
            link.textContent = `ğŸ“ ${name} (${formatSize(size)})`;
            link.style.color = isSelf ? 'white' : '#0084ff';
            link.style.textDecoration = 'underline';
            content = link;
          }
        } else if (parsed && parsed.type === 'p2p-file') {
          // ç¾¤é‡Œå ä½æ¡ç›®ï¼šç‚¹å‡»å†å»ºé“¾æ‹‰å– + æ˜¾ç¤ºå‘é€è€…ä¿¡æ¯
          const { fileId, name, size, from } = parsed;
          const wrap = document.createElement('div');
          const a = document.createElement('a');
          a.href = '#';
          a.textContent = `ğŸ“ ${name} (${(size/1024).toFixed(1)} KB) â€” ç‚¹å‡»ä¸‹è½½`;
          a.onclick = (ev) => {
            ev.preventDefault();
            // ä»…åœ¨â€œè‡ªå·±æ˜¯å‘é€è€…â€æ—¶æ£€æŸ¥æœ¬åœ°ç¼“å­˜ï¼›å…¶ä»–ç”¨æˆ·åº”å§‹ç»ˆå‘èµ·è¯·æ±‚ç»™å‘é€è€…
            if (from === myUserId) {
              if (!window.pendingFiles || !window.pendingFiles[fileId]) {
                alert('æ–‡ä»¶å·²å¤±æ•ˆï¼Œå‘é€è€…ç«¯æœªç¼“å­˜è¯¥æ–‡ä»¶');
                return;
              }
            }
            requestFile(from, fileId);
          };
          a.style.color = isSelf ? 'white' : '#0084ff';
          a.style.textDecoration = 'underline';
          const meta = document.createElement('div');
          meta.style.fontSize = '12px';
          meta.style.color = isSelf ? '#a0d4ff' : '#666';
          meta.textContent = `æ¥è‡ªç”¨æˆ·ï¼š${from}`;
          wrap.appendChild(a);
          wrap.appendChild(meta);
          content = wrap;
        }
      } catch (e) {
        // æ™®é€šæ–‡æœ¬
      }

      if (!isFile && !content) {
        content = document.createTextNode(msg.text);
      }

      // æ¶ˆæ¯æ°”æ³¡
      const bubble = document.createElement('div');
      bubble.className = 'bubble';
      if (content instanceof Node) {
        bubble.appendChild(content);
      } else {
        bubble.textContent = content;
      }

      // ç”¨æˆ·å
      const header = document.createElement('div');
      header.className = 'header';
      header.textContent = msg.from;

      // æ—¶é—´
      const timeEl = document.createElement('div');
      timeEl.className = 'time';
      timeEl.textContent = msg.time;

      div.appendChild(header);
      div.appendChild(bubble);
      div.appendChild(timeEl);

      chatBox.appendChild(div);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    async function sendMessage() {
      const input = document.getElementById('messageInput');
      const btn = document.getElementById('sendBtn');
      const text = input.value.trim();
      if (!text) return;
      if (!myUserId) { console.warn('[send] myUserId æœªåˆå§‹åŒ–ï¼Œç¨åé‡è¯•'); alert('æ­£åœ¨è¿æ¥æœåŠ¡å™¨ï¼Œè¯·ç¨åå†è¯•'); return; }

      try {
        btn.disabled = true; btn.classList.add('disabled');
        const res = await fetch(`http://${serviceUrl}/send`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: text, from: myUserId })
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        input.value = '';
      } catch (err) {
        console.error('[send:error]', err);
        alert('å‘é€å¤±è´¥ï¼Œè¯·é‡è¯•');
      } finally {
        btn.disabled = false; btn.classList.remove('disabled');
      }
    }

    // æ˜¾å¼æŒ‚è½½åˆ° windowï¼Œç¡®ä¿å†…è” onclick å¯è®¿é—®
    window.sendMessage = sendMessage;

    function pickP2PUpload() {
      const input = document.getElementById('fileInput');
      input.onchange = () => uploadFileP2P();
      input.click();
    }
    window.pickP2PUpload = pickP2PUpload;

    function pickServerUpload() {
      const input = document.getElementById('fileInputServer');
      input.onchange = () => uploadFileServer();
      input.click();
    }
    window.pickServerUpload = pickServerUpload;

    // ç›´ä¼ ç»™æŒ‡å®šç”¨æˆ·ï¼ˆç«‹å³å»ºé“¾å¹¶å‘é€ï¼‰
    async function uploadFileDirect(targetUserId) {
      const input = document.getElementById('fileInputDirect');
      const file = input.files[0];
      if (!file || !myUserId) return;
      await connectToUser(targetUserId);
      await new Promise(res => { const check=()=>{ if (dataChannels[targetUserId]) res(); else setTimeout(check,200)}; check(); });
      const channel = dataChannels[targetUserId];
      try {
        await waitForIceConnected(peerConnections[targetUserId]);
        await waitForChannelOpen(channel);
      } catch (e) { console.error('[direct] open failed', e); alert('P2P è¿æ¥æœªå°±ç»ªï¼Œè¯·ç¨åå†è¯•'); return; }
      const container = document.createElement('div');
      container.className = 'message self';
      const prog = ensureProgress(container, `send-${targetUserId}-${Date.now()}`, `å‘é€ç»™ ${targetUserId}ï¼š${file.name}`);
      document.getElementById('chatBox').appendChild(container);
      if (channel.readyState !== 'open') { alert('P2P é€šé“æœªå°±ç»ª'); return; }
      try { channel.send(JSON.stringify({ type: 'file-meta', name: file.name, size: file.size, mime: file.type || 'application/octet-stream' })); } catch (e) { console.error('[direct] meta send failed', e); alert('P2P å…ƒä¿¡æ¯å‘é€å¤±è´¥'); return; }
      // åˆ†ç‰‡+é˜ˆå€¼é™æµï¼ˆå°åˆ†ç‰‡ + bufferedamountlowï¼‰
      const reader = file.stream().getReader();
      let sent = 0; const start = Date.now(); let lastT = start, lastB = 0; let canceled = false;
      const onClose = () => { canceled = true; prog.info.textContent = `è¿æ¥å·²å…³é—­ï¼š${file.name}`; };
      channel.addEventListener('close', onClose);
      const SLICE = 64 * 1024; // 64KB
      channel.bufferedAmountLowThreshold = 256 * 1024;
      const waitBufferedLow = async () => {
        if (channel.bufferedAmount <= channel.bufferedAmountLowThreshold) return;
        await new Promise(resolve => {
          const h = () => { channel.removeEventListener('bufferedamountlow', h); resolve(); };
          channel.addEventListener('bufferedamountlow', h);
        });
      };
      while (true) {
        const { done, value } = await reader.read();
        if (done || canceled) break;
        if (channel.readyState !== 'open') { console.warn('[direct] channel not open during send'); break; }
        const chunkView = value instanceof Uint8Array ? value : new Uint8Array(value);
        for (let off = 0; off < chunkView.byteLength; off += SLICE) {
          if (canceled) break;
          if (channel.readyState !== 'open') { console.warn('[direct] channel not open during send'); canceled = true; break; }
          const piece = chunkView.subarray(off, Math.min(off + SLICE, chunkView.byteLength));
          await waitBufferedLow();
          try { channel.send(piece); } catch (e) { console.error('[direct] chunk send failed', e); canceled = true; break; }
          sent += piece.byteLength;
          const now = Date.now();
          const dt = (now - lastT)/1000; const db = sent - lastB;
          if (dt >= 0.5) {
            const speed = db/dt; const remain = Math.max(0, file.size - sent);
            const eta = speed>0 ? remain/speed : 0;
            prog.meta.textContent = `${(speed/1024).toFixed(1)} KB/sï¼Œå‰©ä½™çº¦ ${eta.toFixed(1)} s`;
            lastT = now; lastB = sent;
          }
          prog.bar.style.width = Math.round((sent/file.size)*100) + '%';
        }
      }
      if (!canceled && channel.readyState === 'open') {
        await waitBufferedLow();
        try { channel.send(JSON.stringify({ type: 'file-end' })); } catch {}
        prog.info.textContent = `å‘é€ç»™ ${targetUserId}ï¼š${file.name}ï¼ˆå®Œæˆï¼‰`;
        prog.bar.style.width = '100%';
      }
      input.value = '';
      // å–æ¶ˆæ”¯æŒï¼šç‚¹å‡»å–æ¶ˆæŒ‰é’®ä¸­æ–­è¯»å–
      prog.cancelBtn.onclick = () => {
        try { reader.cancel(); } catch {}
        prog.info.textContent = `å·²å–æ¶ˆï¼š${file.name}`;
        prog.meta.textContent = '';
      };
    }

    // æ”¹ä¸ºä»…å¹¿æ’­æ–‡ä»¶å…ƒä¿¡æ¯ï¼Œå ä½ï¼›ç‚¹å‡»æ—¶å†å»ºç«‹è¿æ¥ä¼ è¾“ï¼ˆP2Pï¼‰
    async function uploadFileP2P() {
      const fileInput = document.getElementById('fileInput');
      const file = fileInput.files[0];
      if (!file || !myUserId) return;

      const fileId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      window.pendingFiles = window.pendingFiles || {};
      window.pendingFiles[fileId] = file; // å‘é€è€…æœ¬åœ°ç¼“å­˜

      // å‘ç¾¤é‡Œå¹¿æ’­å ä½æ¶ˆæ¯
      await fetch(`http://${serviceUrl}/send`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: JSON.stringify({ type: 'p2p-file', fileId, name: file.name, size: file.size, from: myUserId }),
          from: myUserId
        })
      });

      // è‡ªå·±æœ¬åœ°æ˜¾ç¤ºä¸€æ¡å ä½ï¼ˆç‚¹å‡»ä¹Ÿå¯ä»¥è‡ªæˆ‘ä¸‹è½½ï¼‰
      addMessageToUI({
        from: myUserId,
        time: new Date().toLocaleTimeString(),
        text: JSON.stringify({ type: 'p2p-file', fileId, name: file.name, size: file.size, from: myUserId })
      });

      fileInput.value = '';
    }

    // ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼ˆå¸¦è¿›åº¦æ¡ï¼‰
    async function uploadFileServer() {
      const input = document.getElementById('fileInputServer');
      const file = input.files[0];
      if (!file || !myUserId) return;

      // åœ¨è‡ªå·±çš„æ¶ˆæ¯åŒºæ’å…¥è¿›åº¦æ¡
      const container = document.createElement('div');
      container.className = 'message self';
      const prog = ensureProgress(container, `server-${Date.now()}-${file.name}`, `ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼š${file.name}`);
      document.getElementById('chatBox').appendChild(container);

      const formData = new FormData();
      formData.append('file', file);

      // ä½¿ç”¨ XMLHttpRequest ä»¥ä¾¿è¿½è¸ªä¸Šä¼ è¿›åº¦
      await new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', `http://${serviceUrl}/upload`);
        xhr.upload.onprogress = (e) => {
          if (e.lengthComputable) {
            const pct = Math.min(100, Math.round((e.loaded / e.total) * 100));
            prog.bar.style.width = pct + '%';
          }
        };
        xhr.onload = () => {
          if (xhr.status >= 200 && xhr.status < 300) resolve(JSON.parse(xhr.responseText)); else reject(new Error(xhr.statusText));
        };
        xhr.onerror = reject;
        xhr.send(formData);
      }).then(async () => {
        // ä¸Šä¼ æˆåŠŸåï¼Œå¹¿æ’­æ–‡ä»¶é“¾æ¥æ¶ˆæ¯
        const res = await fetch(`http://${serviceUrl}/api/files`);
        const list = await res.json();
        const found = list.find(x => x.name === file.name) || null;
        if (found) {
          await fetch(`http://${serviceUrl}/send`, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              message: JSON.stringify({ type: 'file', url: found.url, name: found.name, size: found.size }),
              from: myUserId
            })
          });
          prog.info.textContent = `ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼š${file.name}ï¼ˆå®Œæˆï¼‰`;
          prog.bar.style.width = '100%';
        } else {
          prog.info.textContent = `ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼š${file.name}ï¼ˆæˆåŠŸï¼Œç´¢å¼•æœªæ‰¾åˆ°ï¼‰`;
        }
      }).catch(err => {
        console.error(err);
        prog.info.textContent = `ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼š${file.name}ï¼ˆå¤±è´¥ï¼‰`;
        console.error('[server:upload:error]', err);
      });

      input.value = '';
    }

    async function requestFile(fromUserId, fileId) {
      // å»ºç«‹åˆ°å‘é€è€…çš„è¿æ¥
      console.log('[requestFile] start', { fromUserId, fileId });
      await connectToUser(fromUserId);
      await new Promise(resolve => {
        const check = () => {
          if (dataChannels[fromUserId]) resolve();
          else setTimeout(check, 200);
        };
        check();
      });
      await waitForChannelOpen(dataChannels[fromUserId]);
      // å‘é€è¯·æ±‚
      console.log('[requestFile] send request', { to: fromUserId, fileId });
      dataChannels[fromUserId].send(JSON.stringify({ type: 'p2p-file-request', fileId }));
    }

    // å³ä¸Šè§’è®¾ç½®å¼¹çª—äº¤äº’
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const settingsClose = document.getElementById('settingsClose');
    settingsBtn.addEventListener('click', () => { settingsModal.style.display = 'flex'; const sw=document.getElementById('lanModeSwitch'); if (sw) sw.checked = lanMode; });
    settingsClose.addEventListener('click', () => { settingsModal.style.display = 'none'; });
    settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) settingsModal.style.display = 'none'; });

    // è®¾ç½®ï¼šLAN æ¨¡å¼å¼€å…³
    document.addEventListener('change', (e) => {
      if (e.target && e.target.id === 'lanModeSwitch') {
        lanMode = !!e.target.checked;
        console.log('[settings] lanMode =', lanMode);
      }
    });

    // æµ‹è¯•æŒ‰é’®ç»‘å®š
    document.getElementById('testSendText').addEventListener('click', async () => {
      const text = 'Hello from settings panel';
      try {
        const res = await fetch(`http://${serviceUrl}/send`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: text, from: myUserId || 'PANEL_'+Date.now() }) });
        alert('å‘é€æ–‡æœ¬å®Œæˆ: ' + res.status);
      } catch (e) { alert('å‘é€å¤±è´¥: ' + e.message); }
    });
    document.getElementById('testWS').addEventListener('click', () => {
      try {
        const ws2 = new WebSocket(`ws://${serviceUrl}/ws`);
        ws2.onopen = () => alert('[WS] open');
        ws2.onerror = (e) => alert('[WS] error');
        ws2.onclose = () => console.log('[WS] close');
      } catch(e) { alert(e.message); }
    });
    document.getElementById('testP2PPlaceholder').addEventListener('click', async () => {
      const fileId = 'TESTFILE_' + Date.now();
      const name = 'dummy.jpg'; const size = 128*1024;
      await fetch(`http://${serviceUrl}/send`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: JSON.stringify({ type: 'p2p-file', fileId, name, size, from: myUserId }), from: myUserId }) });
      alert('å·²ç¾¤å‘å ä½: ' + fileId);
    });
    document.getElementById('testFilesList').addEventListener('click', async () => {
      const res = await fetch(`http://${serviceUrl}/api/files`); const list = await res.json();
      alert('files: ' + list.length);
      console.log('[files]', list);
    });
    document.getElementById('testUploadSmall').addEventListener('click', async () => {
      const file = new File([new Blob(['settings panel upload'])], 'panel.txt', { type:'text/plain' });
      const fd = new FormData(); fd.append('file', file);
      await new Promise((resolve,reject)=>{ const xhr=new XMLHttpRequest(); xhr.open('POST', `http://${serviceUrl}/upload`); xhr.onload=()=>{ (xhr.status>=200&&xhr.status<300)?resolve():reject(new Error(xhr.statusText)); }; xhr.onerror=reject; xhr.send(fd); });
      alert('ä¸Šä¼ å®Œæˆ');
    });
    document.getElementById('testSignal').addEventListener('click', () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return alert('WSæœªè¿æ¥');
      const to = prompt('è¾“å…¥ç›®æ ‡ç”¨æˆ·ID'); if (!to) return;
      const payload = { type:'ping', from: myUserId, to, payload:{ ts: Date.now() } };
      ws.send(JSON.stringify({ type:'signal', data: payload }));
      alert('å·²å‘é€ä¿¡ä»¤åˆ° ' + to);
    });

    // äº‹ä»¶ç»‘å®šï¼ˆæ›¿ä»£å†…è” onclickï¼‰ï¼Œæ›´ç¨³å¥
    document.getElementById('sendBtn').addEventListener('click', () => {
      try { sendMessage(); } catch (err) { console.error('[sendMessage:error]', err); }
    });
    // æ‰“å¼€èœå•
    const fileSendBtn = document.getElementById('fileSendBtn');
    const fileSendMenu = document.getElementById('fileSendMenu');
    fileSendBtn.addEventListener('click', () => {
      // åŒæ­¥åœ¨çº¿ç”¨æˆ·åˆ°èœå•ä¸‹æ‹‰
      const sel = document.getElementById('menuTargetUser');
      sel.innerHTML = '<option value="">è¯·é€‰æ‹©ç”¨æˆ·</option>';
      onlineUsers.forEach(u => { const opt = document.createElement('option'); opt.value = u; opt.textContent = u; sel.appendChild(opt); });
      fileSendMenu.style.display = 'block';
    });

    // èœå•äº¤äº’ï¼šåˆ‡æ¢ç›´ä¼ æ—¶æ˜¾ç¤ºç”¨æˆ·é€‰æ‹©
    fileSendMenu.addEventListener('change', (e) => {
      if (e.target.name === 'sendMode') {
        document.getElementById('menuTargetWrap').style.display = (e.target.value === 'direct') ? 'block' : 'none';
      }
    });

    // èœå•å–æ¶ˆ
    document.getElementById('menuCancel').addEventListener('click', () => {
      fileSendMenu.style.display = 'none';
    });

    // èœå•ç¡®è®¤
    document.getElementById('menuConfirm').addEventListener('click', () => {
      const mode = [...fileSendMenu.querySelectorAll('input[name="sendMode"]')].find(r => r.checked)?.value;
      if (!mode) return;
      fileSendMenu.style.display = 'none';
      if (mode === 'p2p') pickP2PUpload();
      else if (mode === 'server') pickServerUpload();
      else if (mode === 'direct') {
        const target = document.getElementById('menuTargetUser').value;
        if (!target) { alert('è¯·é€‰æ‹©æ¥æ”¶ç”¨æˆ·'); return; }
        const input = document.getElementById('fileInputDirect');
        input.onchange = () => uploadFileDirect(target);
        input.click();
      }
    });

    document.getElementById('messageInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        try { sendMessage(); } catch (err) { console.error('[sendMessage:error]', err); }
      }
    });

    // åœ¨çº¿ç”¨æˆ·ä¸‹æ‹‰åˆ·æ–°ï¼ˆå…¼å®¹å­˜åœ¨ä¸å¦ï¼‰
    function refreshTargetUser() {
      const ids = ['menuTargetUser', 'targetUser'];
      ids.forEach(id => {
        const sel = document.getElementById(id);
        if (!sel) return;
        const keep = sel.value;
        // æ ¹æ®ä¸åŒä¸‹æ‹‰å±•ç¤ºä¸åŒé»˜è®¤é¡¹
        if (id === 'menuTargetUser') {
          sel.innerHTML = '<option value="">è¯·é€‰æ‹©ç”¨æˆ·</option>';
        } else {
          sel.innerHTML = '<option value="">ï¼ˆä¸æŒ‡å®šï¼‰</option>';
        }
        onlineUsers.forEach(u => {
          const opt = document.createElement('option');
          opt.value = u; opt.textContent = u;
          sel.appendChild(opt);
        });
        if ([...sel.options].some(o => o.value === keep)) sel.value = keep;
      });
    }

    connectWebSocket();
  </script>
</body>
</html>
