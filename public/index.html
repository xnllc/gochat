<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="icon" href="/gochat.ico" type="image/x-icon">
  <title>ğŸ’¬ å®æ—¶èŠå¤©</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f0f2f5;
    }
    /* å³ä¸Šè§’è®¾ç½®æŒ‰é’® */
    #settingsBtn { position: fixed; top: 12px; right: 12px; z-index: 20; background: #fff; border: 1px solid #ddd; border-radius: 50%; width: 40px; height: 40px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); cursor: pointer; display: flex; align-items: center; justify-content: center; }
    #settingsBtn:hover { background: #f7f7f7; }
    /* è®¾ç½®å¼¹çª— */
    #settingsModal { position: fixed; inset: 0; background: rgba(0,0,0,0.35); display: none; align-items: center; justify-content: center; z-index: 30; }

    /* å³ä¾§åœ¨çº¿ç”¨æˆ·é¢æ¿ */
    #onlinePanel { position: fixed; top: 64px; right: 16px; bottom: 16px; width: 260px; background:#fff; border:1px solid #e5e5e5; border-radius: 10px; box-shadow: 0 4px 16px rgba(0,0,0,0.08); padding: 12px; overflow: auto; z-index: 15; display:none; }
    #onlineToggle { position: fixed; top: 64px; right: 16px; width: 40px; height: 40px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer; z-index: 16; }
    #onlinePanel .hd { font-weight: 600; margin-bottom: 8px; display:flex; align-items:center; justify-content:space-between; }
    #onlineList .item { display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 6px; border-bottom:1px solid #f3f3f3; }
    #onlineList .id { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; color:#555; }
    #onlineList .ops { display:flex; gap:6px; }
    #onlineList .ops button { padding:4px 8px; border-radius:6px; font-size:12px; border:1px solid #ddd; background:#fafafa; color:#333; cursor:pointer; }
    #onlineList .ops button:hover { background:#f0f0f0; }

    /* å®½å±æ—¶ä¸ºä¸»ä½“å†…å®¹é¢„ç•™å³ä¾§è¾¹è·ï¼Œé¿å…è¢«é¢æ¿é®æŒ¡ */
    @media (min-width: 1100px) {
      body { padding-right: 280px; }
    }
    /* çª„å±éšè—é¢æ¿ */
    @media (max-width: 1099px) {
      #onlinePanel { display:none; }
    }
    #settingsModal .panel { background: #fff; width: 520px; max-width: calc(100% - 40px); border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); overflow: hidden; }
    #settingsModal .panel .hd { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #eee; font-weight: 600; }
    #settingsModal .panel .bd { padding: 16px; max-height: 70vh; overflow: auto; }
    .test-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .test-grid button { padding: 10px 12px; border-radius: 8px; border: 1px solid #ddd; background: #fafafa; color: #333; cursor: pointer; }
    .test-grid button:hover { background: #f0f0f0; }
    #settingsModal .panel { color:#333; }
    #settingsModal .panel .hd { color:#333; }
    .muted { color:#999; font-size: 12px; }

    .progress {
      height: 6px;
      background: rgba(0,0,0,0.1);
      border-radius: 3px;
      overflow: hidden;
      margin-top: 6px;
    }
    .progress > .bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #4caf50, #81c784);
      transition: width 0.1s ease;
    }
    .actions-row { display:flex; gap:8px; align-items:center; margin-top:6px; }
    .small { font-size:12px; color:#666; }
    .muted { color:#999; }
    .btn-sm { padding:6px 10px; border-radius:12px; font-size:12px; }
    .disabled { opacity:0.5; pointer-events:none; }
    #container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      max-width: 1000px;
      margin: 0 auto;
      width: 100%;
      padding: 16px;
    }
    h1 {
      text-align: center;
      margin-bottom: 12px;
      color: #333;
      font-size: 1.4em;
    }
    .chatbox {
      flex: 1;
      overflow-y: auto;
      background: white;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      min-height: 200px;
    }
    .message {
      max-width: 80%;
      margin-bottom: 16px;
      position: relative;
    }
    .system {
      color: #888;
      font-style: italic;
      text-align: center;
      font-size: 0.9em;
      align-self: center;
      margin-top: 8px;
      margin-bottom: 8px;
    }

    /* è‡ªå·±çš„æ¶ˆæ¯ï¼šé å³ */
    .self {
      align-self: flex-end;
      text-align: right;
    }
    .self .bubble {
      background: #0084ff;
      color: white;
      border-radius: 18px 18px 4px 18px;
    }

    /* ä»–äººæ¶ˆæ¯ï¼šé å·¦ */
    .other {
      align-self: flex-start;
      text-align: left;
    }
    .other .bubble {
      background: #e5e5ea;
      color: black;
      border-radius: 18px 18px 18px 4px;
    }

    .bubble {
      padding: 12px 16px;
      word-wrap: break-word;
      white-space: pre-wrap; /* ä¿ç•™æ¢è¡Œä½†ä¸å¼ºåˆ¶æ¯ä¸ªå­—æ¢è¡Œ */
      line-height: 1.4;
      display: inline-block;
      max-width: 100%;
    }

    .header {
      font-size: 0.8em;
      margin-bottom: 4px;
      font-weight: bold;
    }
    .self .header {
      color: #a0d4ff;
      text-align: right;
    }
    .other .header {
      color: #666;
      text-align: left;
    }

    .time {
      font-size: 0.7em;
      color: #999;
      margin-top: 4px;
      text-align: right;
    }

    .inputArea {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    #targetUser { padding: 8px 10px; border:1px solid #ccc; border-radius: 8px; background:#fff; }
    #messageInputGroup, #messageInputPrivate {
      flex: 1;
      width: 100%;
      padding: 14px 18px;
      border: 1px solid #ccc;
      border-radius: 24px;
      outline: none;
      font-size: 16px;
      min-height: 44px;
    }
    button {
      padding: 12px 20px;
      border: none;
      border-radius: 24px;
      background: #0084ff;
      color: white;
      cursor: pointer;
      font-size: 16px;
      white-space: nowrap;
    }
    button:hover {
      opacity: 0.9;
    }
    #uploadBtn {
      background: #4caf50;
    }
    #fileInput {
      display: none;
    }
    #chatBoxesPrivate { flex: 1; }
  </style>
</head>
<body>
  <div id="container">
    <img id="onlineToggle" src="/img2.png" alt="åœ¨çº¿ç”¨æˆ·" title="å±•å¼€åœ¨çº¿ç”¨æˆ·" />
    <div id="onlinePanel">
      <div class="hd">åœ¨çº¿ç”¨æˆ· (<span id="onlineCount">0</span>)
        <button id="refreshUsers" class="btn-sm" style="background:#eee;color:#333;">åˆ·æ–°</button>
      </div>
      <div id="onlineList"></div>
    </div>

    <button id="settingsBtn" title="è®¾ç½®ä¸æµ‹è¯•" aria-label="è®¾ç½®">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 1 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9c0 .66.26 1.3.73 1.77.47.47 1.11.73 1.77.73H21a2 2 0 1 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
      </svg>
    </button>
    <div id="settingsModal">
      <div class="panel">
        <div class="hd">
          <span>è®¾ç½®ä¸æµ‹è¯•</span>
          <button id="settingsClose" class="btn-sm">å…³é—­</button>
        </div>
        <div class="bd">
          <div class="muted" style="margin-bottom:8px;">å¿«é€Ÿæµ‹è¯•å¸¸ç”¨æ¥å£ä¸é€šé“</div>
          <div style="margin-bottom:10px; display:flex; align-items:center; gap:8px;">
            <input type="checkbox" id="lanModeSwitch" />
            <label for="lanModeSwitch">å¯ç”¨ LAN ä¼˜åŒ–æ¨¡å¼ï¼ˆä»…ä½¿ç”¨æœ¬åœ°å±€åŸŸç½‘å€™é€‰ï¼Œè·³è¿‡å…¬ç½‘ STUNï¼‰</label>
          </div>
          <div style="margin-bottom:12px; display:flex; align-items:center; gap:8px;">
            <label for="nickInput" style="white-space:nowrap;">æ˜µç§°ï¼š</label>
            <input id="nickInput" type="text" placeholder="è¾“å…¥ä½ çš„æ˜µç§°ï¼ˆä»…æœ¬æœºå¯è§ï¼‰" style="flex:1; padding:8px 10px; border:1px solid #ccc; border-radius:6px;" />
            <label style="display:flex; align-items:center; gap:6px; white-space:nowrap;">
              <input type="checkbox" id="saveNickChk" /> ä¿å­˜æ˜µç§°
            </label>
          </div>
          <div class="actions-row" style="justify-content:flex-start; gap:10px; align-items:center;">
            <button id="resetIdentityBtn" class="btn-sm" style="background:#eee;color:#333;">é‡ç½®èº«ä»½</button>
            <span class="small muted">æ¸…é™¤æœ¬åœ° userIdï¼Œé‡æ–°è¿æ¥ä»¥è·å–æ–°çš„ç”¨æˆ·ID</span>
          </div>

          <div style="margin-top:14px; padding-top:10px; border-top:1px dashed #eee; display:flex; flex-direction:column; gap:10px;">
            <div style="display:flex; align-items:center; gap:8px;">
              <label for="historyLimitInput" style="white-space:nowrap;">èŠå¤©è®°å½•æ¡æ•°ï¼š</label>
              <input id="historyLimitInput" type="number" min="10" max="10000" step="10" style="width:120px; padding:6px 8px; border:1px solid #ccc; border-radius:6px;" />
              <span class="small muted">é»˜è®¤ 100 æ¡ï¼Œè¶…å‡ºå°†è‡ªåŠ¨è£å‰ª</span>
            </div>
            <div class="actions-row" style="justify-content:flex-start; gap:8px;">
              <button id="exportHistoryBtn" class="btn-sm" style="background:#eee;color:#333;">å¯¼å‡ºèŠå¤©è®°å½•</button>
              <button id="importHistoryBtn" class="btn-sm" style="background:#eee;color:#333;">å¯¼å…¥èŠå¤©è®°å½•</button>
            </div>
          </div>
          <div class="test-grid">
            <button id="testSendText">å‘é€æ–‡æœ¬(Hello)</button>
            <button id="testWS">æµ‹è¯• WebSocket</button>
            <button id="testPrivate">å‘é€ç§èŠ(Hello â†’ é€‰æ‹©ç›®æ ‡)</button>
            <button id="testP2PPlaceholder">ç¾¤å‘å ä½(P2P)</button>
            <button id="testFilesList">è·å–æ–‡ä»¶åˆ—è¡¨</button>
            <button id="testUploadSmall">ä¸Šä¼ å°æ–‡ä»¶</button>
            <button id="testSignal">å‘é€ä¿¡ä»¤(ping)</button>
          </div>
        </div>
      </div>
    </div>

    <h1>ğŸ’¬ å±€åŸŸç½‘ä¸´æ—¶æµ‹è¯•æ”¶å‘ä¿¡æ¯å’Œæ–‡ä»¶</h1>
    <div id="chatTabs" style="display:flex; gap:8px; margin:8px 0;">
      <button id="tabGroup" class="btn-sm" style="background:#0084ff;color:#fff;">ç¾¤èŠ</button>
      <div id="privateTabs" style="display:flex; gap:8px;"></div>
    </div>
    <div id="chatBoxGroup" class="chatbox" style="display:flex;"></div>
    <div id="chatBoxesPrivate" style="display:none;"></div>
    <div id="privateInputs" class="inputArea" style="display:none; flex-direction:column; gap:12px;"></div>
    <div id="inputAreaGroup" class="inputArea">
      <input type="text" id="messageInputGroup" placeholder="åœ¨ç¾¤èŠä¸­è¾“å…¥æ¶ˆæ¯..." autocomplete="off" />
      <button id="sendBtnGroup">å‘é€</button>
      <button id="fileSendBtnGroup">ğŸ“ æ–‡ä»¶å‘é€</button>
    </div>

    <!-- ç§èŠè¾“å…¥åŒºå®¹å™¨ï¼ˆåŠ¨æ€æ·»åŠ å¤šä¸ªä¼šè¯è¾“å…¥æ¡†ï¼‰ -->
    <div id="privateInputsContainer" class="inputArea" style="display:none; flex-direction:column; gap:12px;"></div>

    <!-- æ–‡ä»¶å‘é€é€‰é¡¹èœå• -->
    <div id="fileSendMenu" style="display:none; position:fixed; right:16px; bottom:80px; background:#fff; border:1px solid #ddd; border-radius:8px; box-shadow:0 4px 16px rgba(0,0,0,0.12); padding:12px; min-width:260px; z-index:50;">
      <div style="font-weight:600; margin-bottom:8px;">é€‰æ‹©å‘é€æ–¹å¼</div>
      <label style="display:block; margin:6px 0;">
        <input type="radio" name="sendMode" value="p2p" checked /> P2P ç¾¤é‡Œå ä½ï¼Œç‚¹å‡»åå†ä¼ 
      </label>
      <label style="display:block; margin:6px 0;">
        <input type="radio" name="sendMode" value="direct" /> ç›´ä¼ ç»™é€‰ä¸­ç”¨æˆ·
      </label>
      <div id="menuTargetWrap" style="margin-left:18px; margin-top:4px; display:none;">
        <select id="menuTargetUser" style="padding:6px 8px; border-radius:6px; border:1px solid #ccc; min-width:160px">
          <option value="">è¯·é€‰æ‹©ç”¨æˆ·</option>
        </select>
      </div>
      <label style="display:block; margin:6px 0;">
        <input type="radio" name="sendMode" value="server" /> ä¸Šä¼ åˆ°æœåŠ¡å™¨å¹¶ç¾¤å‘é“¾æ¥
      </label>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px;">
        <button id="menuCancel" class="btn-sm" style="background:#eee;color:#333;">å–æ¶ˆ</button>
        <button id="menuConfirm" class="btn-sm" style="background:#0084ff; color:#fff;">ç¡®å®š</button>
      </div>
    </div>
    <input id="fileInput" type="file" style="display:none;" />
    <input id="fileInputServer" type="file" style="display:none;" />
    <input id="fileInputDirect" type="file" style="display:none;" />
  </div>

  <script>
    const serviceUrl = window.location.host;
    let myUserId = '';
    let ws = null;
    // æœ¬åœ°æ˜µç§°ï¼ˆä»…æœ¬æœºå±•ç¤ºç”¨ï¼‰
    let displayName = localStorage.getItem('nickname') || '';
    let peerConnections = {}; // userId -> RTCPeerConnection
    let dataChannels = {};    // userId -> RTCDataChannel
    let onlineUsers = [];     // åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ï¼ˆæ¥è‡ªæœåŠ¡ç«¯å¹¿æ’­ï¼‰

    // æœ¬åœ°èŠå¤©è®°å½•ä¸é…ç½®
    const HISTORY_KEY = 'chatHistoryV1';
    const HISTORY_LIMIT_KEY = 'chatHistoryLimit';
    let historyLimit = parseInt(localStorage.getItem(HISTORY_LIMIT_KEY) || '100', 10);
    let historyStore = { group: [], private: {} }; // { group: Message[], private: { [userId]: Message[] } }

    // ä»æœ¬åœ°æ¢å¤å†å²
    try {
      const raw = localStorage.getItem(HISTORY_KEY);
      if (raw) {
        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === 'object') {
          historyStore = { group: parsed.group || [], private: parsed.private || {} };
        }
      }
    } catch (e) { console.warn('[history] parse error', e); }

    function connectWebSocket() {
      const uid = localStorage.getItem('userId') || '';
      ws = new WebSocket(`ws://${serviceUrl}/ws${uid ? ('?uid=' + encodeURIComponent(uid)) : ''}`);

      ws.onopen = () => {
        console.log('[ws] open');
        // åˆæ¬¡è¿æ¥å®Œæˆåï¼Œæ¸²æŸ“ç¾¤èŠå†å²
        try {
          const box = document.getElementById('chatBoxGroup');
          if (box && !box.dataset.inited) {
            box.dataset.inited = '1';
            (historyStore.group || []).slice(-historyLimit).forEach(r => addMessageToUI({ text: r.text, from: r.from, time: r.time }));
          }
        } catch (e) { console.warn('[history] render group error', e); }
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        if (data.type === 'init') {
          myUserId = data.userId;
          try { localStorage.setItem('userId', myUserId); } catch {}
          console.log('[ws:init] myUserId', myUserId);
        } else if (data.type === 'message') {
          addMessageToUI(data.data);
        } else if (data.type === 'private') {
          const m = data.data; m.private = true; addMessageToUI(m);
        } else if (data.type === 'users') {
          // ç³»ç»Ÿå¹¿æ’­åœ¨çº¿ç”¨æˆ·åˆ—è¡¨ï¼ˆé€—å·åˆ†éš”ï¼‰
          onlineUsers = data.data.text ? data.data.text.split(',').filter(u => u && u !== myUserId) : [];
          console.log('[ws:users]', onlineUsers);
          refreshTargetUser();
          renderOnlineUsers();

        } else if (data.type === 'signal') {
          // æ”¶åˆ°æ¥è‡ªæœåŠ¡ç«¯è½¬å‘çš„ä¿¡ä»¤
          const s = data.data; // { type, from, to, payload }
          handleSignalFromPeer(s);
        }
      };

      ws.onclose = () => {
        console.warn('[ws] close, reconnect in 5s');
        setTimeout(connectWebSocket, 5000);
      };

      ws.onerror = (err) => {
        console.error('[ws] error', err);
      };
    }

    let lanMode = true; // å±€åŸŸç½‘ç›´è¿æ¨¡å¼ï¼Œä¼˜å…ˆç”¨æœ¬åœ°å€™é€‰ï¼Œç»•è¿‡å…¬ç½‘ STUN
    async function createConnection(toUserId) {
      if (peerConnections[toUserId]) { console.log('[pc] reuse', toUserId); return peerConnections[toUserId]; }
      console.log('[pc] create', toUserId, 'lanMode=', lanMode);
      const config = lanMode
        ? { iceServers: [], bundlePolicy: 'max-bundle' }
        : { iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }], bundlePolicy: 'max-bundle' };
      const pc = new RTCPeerConnection(config);

      pc.onicecandidate = (e) => {
        if (e.candidate) {
          const candStr = e.candidate.candidate || '';
          const isHost = /\btyp host\b/.test(candStr);
          const type = (candStr.match(/\btyp (host|srflx|relay)\b/)||[])[1] || 'unknown';
          console.log('[ice:cand:local]', toUserId, type, candStr);
          if (!lanMode || isHost) {
            sendSignal({ type: 'candidate', to: toUserId, payload: { candidate: e.candidate } });
          } else {
            console.log('[ice:cand:drop]', 'non-host in LAN mode');
          }
        }
      };

      pc.ondatachannel = (event) => {
        const channel = event.channel;
        console.log('[pc:ondatachannel]', toUserId, channel.label);
        registerDataChannel(toUserId, channel);
      };
      pc.oniceconnectionstatechange = () => { console.log('[pc:ice]', toUserId, pc.iceConnectionState); };
      pc.onconnectionstatechange = () => { console.log('[pc:state]', toUserId, pc.connectionState); };

      peerConnections[toUserId] = pc;
      return pc;
    }

    async function waitForChannelOpen(channel, timeout = 15000) {
      if (!channel) throw new Error('DataChannel missing');
      if (channel.readyState === 'open') return;
      console.log('[dc] wait open...', channel.readyState);
      await new Promise((resolve, reject) => {
        const start = Date.now();
        const onOpen = () => { cleanup(); resolve(); };
        const check = () => {
          if (channel.readyState === 'open') { cleanup(); resolve(); return; }
          if (channel.readyState === 'closing' || channel.readyState === 'closed') { cleanup(); reject(new Error('DataChannel closed before open')); return; }
          if (Date.now() - start > timeout) { cleanup(); reject(new Error('DataChannel open timeout')); return; }
          setTimeout(check, 50);
        };
        const cleanup = () => { channel.removeEventListener('open', onOpen); };
        channel.addEventListener('open', onOpen);
        check();
      });
      console.log('[dc] opened');
    }

    async function waitForIceConnected(pc, timeout = 15000) {
      if (!pc) throw new Error('PeerConnection missing');
      const ok = s => s === 'connected' || s === 'completed';
      if (ok(pc.iceConnectionState)) return;
      console.log('[ice] wait...', pc.iceConnectionState);
      await new Promise((resolve, reject) => {
        const start = Date.now();
        const onChange = () => {
          const s = pc.iceConnectionState;
          console.log('[ice] state', s);
          if (ok(s)) { cleanup(); resolve(); }
          else if (['failed','disconnected','closed'].includes(s)) { cleanup(); reject(new Error('ICE ' + s)); }
        };
        const timer = setInterval(() => {
          if (ok(pc.iceConnectionState)) { cleanup(); resolve(); }
          else if (Date.now() - start > timeout) { cleanup(); reject(new Error('ICE timeout')); }
        }, 200);
        const cleanup = () => { clearInterval(timer); pc.removeEventListener('iceconnectionstatechange', onChange); };
        pc.addEventListener('iceconnectionstatechange', onChange);
      });
      console.log('[ice] connected');
    }

    function registerDataChannel(toUserId, channel) {
      dataChannels[toUserId] = channel;
      channel.onopen = () => { console.log('[dc] open', toUserId); };
      channel.onclose = () => { console.log('[dc] close', toUserId); };
      channel.onerror = (e) => { console.error('[dc] error', toUserId, e); };

      let receiving = { name: '', size: 0, mime: 'application/octet-stream', chunks: [], received: 0 };

      channel.binaryType = 'arraybuffer';
      channel.onmessage = async (e) => { console.log('[DC:onmessage]', toUserId, typeof e.data);
        if (typeof e.data === 'string') {
          try {
            const msg = JSON.parse(e.data);
            if (msg.type === 'text') {
              addMessageToUI({ text: msg.text, from: toUserId, time: new Date().toLocaleTimeString() });
            } else if (msg.type === 'file-meta') {
              receiving = { name: msg.name, size: msg.size, mime: msg.mime || 'application/octet-stream', chunks: [], received: 0 };
            } else if (msg.type === 'file-end') {
              const blob = new Blob(receiving.chunks, { type: receiving.mime });
              const url = URL.createObjectURL(blob);
              const ext = receiving.name.split('.').pop()?.toLowerCase() || '';
              const isImage = ['jpg','jpeg','png','gif','webp','bmp'].includes(ext);
              const node = isImage
                ? (() => { const img = document.createElement('img'); img.src = url; img.alt = receiving.name; img.style.maxWidth = '100%'; img.style.borderRadius = '8px'; img.style.marginTop = '6px'; img.onclick = () => window.open(url, '_blank'); return img; })()
                : (() => { const a = document.createElement('a'); a.href = url; a.download = receiving.name; a.textContent = `ğŸ“ ${receiving.name} (${(receiving.size/1024).toFixed(1)} KB)`; return a; })();
              addMessageToUI({ from: toUserId, time: new Date().toLocaleTimeString(), contentNode: node });
              console.log('[recv:file-end]', { from: toUserId, name: receiving.name });
              receiving = { name: '', size: 0, mime: 'application/octet-stream', chunks: [], received: 0 };
            } else if (msg.type === 'file-meta') {
              console.log('[recv:file-meta]', { from: toUserId, name: msg.name, size: msg.size });
              // æ¥æ”¶ç«¯æ˜¾ç¤ºè¿›åº¦æ¡ï¼ˆæ˜¾ç¤ºå‘é€è€…ï¼‰
              const container = document.createElement('div');
              container.className = 'message other';
              const prog = ensureProgress(container, `recv-${toUserId}-${msg.name}`, `æ¥è‡ª ${toUserId}ï¼š${msg.name}`);
              if (msg.private) { ensurePrivateTab(toUserId); document.getElementById('chatBox-' + toUserId).appendChild(container); }
              else { document.getElementById('chatBoxGroup').appendChild(container); }
            } else if (msg.type === 'p2p-file-request') {
              // åªæœ‰å‘é€è€…ä¼šå¤„ç†è¯¥è¯·æ±‚ï¼šæŸ¥æ‰¾æœ¬åœ° pendingFilesï¼Œå¯åŠ¨åˆ†ç‰‡å‘é€ï¼Œå¸¦è¿›åº¦
              const fileId = msg.fileId;
              console.log('[p2p-file-request] from', toUserId, fileId);
              const file = window.pendingFiles ? window.pendingFiles[fileId] : null;
              if (!file) { console.warn('[p2p] file not found in sender cache', fileId); return; }
              // åœ¨è‡ªå·±çš„æ¶ˆæ¯åŒºæ˜¾ç¤ºè¿›åº¦æ¡ï¼ˆæ˜¾ç¤ºç›®æ ‡ç”¨æˆ·ï¼‰
              const container = document.createElement('div');
              container.className = 'message self';
              const prog = ensureProgress(container, `send-${toUserId}-${fileId}`, `å‘é€ç»™ ${toUserId}ï¼š${file.name}`);
              if (msg.private) { ensurePrivateTab(toUserId); document.getElementById('chatBox-' + toUserId).appendChild(container); }
              else { document.getElementById('chatBoxGroup').appendChild(container); }
              // ç­‰å¾… ICE ä¸é€šé“æ‰“å¼€å†å‘é€
              await waitForIceConnected(peerConnections[toUserId]).catch(e => { console.warn('[ice] not ready', e); });
              await waitForChannelOpen(channel);
              console.log('[send:file-meta]', { to: toUserId, name: file.name, size: file.size });
              // å‘é€å…ƒä¿¡æ¯ï¼ˆå†æ¬¡æ ¡éªŒé€šé“çŠ¶æ€ï¼‰
              if (channel.readyState !== 'open') { throw new Error('DataChannel not open before meta'); }
              try { channel.send(JSON.stringify({ type: 'file-meta', name: file.name, size: file.size, mime: file.type || 'application/octet-stream' })); }
              catch (e) { throw new Error('send meta failed: ' + e.message); }
              // åˆ†ç‰‡+é˜ˆå€¼é™æµï¼ˆå°åˆ†ç‰‡ + bufferedamountlowï¼‰
              const reader = file.stream().getReader();
              let sent = 0; let canceled = false;
              const onClose = () => { canceled = true; prog.info.textContent = `è¿æ¥å·²å…³é—­ï¼š${file.name}`; };
              channel.addEventListener('close', onClose);
              prog.cancelBtn.onclick = () => { canceled = true; try { reader.cancel(); } catch {} prog.info.textContent = `å·²å–æ¶ˆï¼š${file.name}`; prog.meta && (prog.meta.textContent=''); };
              const SLICE = 64 * 1024; // 64KB å°åˆ†ç‰‡
              channel.bufferedAmountLowThreshold = 256 * 1024; // 256KB ä½æ°´ä½
              const waitBufferedLow = async () => {
                if (channel.bufferedAmount <= channel.bufferedAmountLowThreshold) return;
                await new Promise(resolve => {
                  const h = () => { channel.removeEventListener('bufferedamountlow', h); resolve(); };
                  channel.addEventListener('bufferedamountlow', h);
                });
              };
              try {
                let lastT = Date.now(), lastB = 0;
                while (true) {
                  const { done, value } = await reader.read();
                  if (done || canceled) break;
                  if (channel.readyState !== 'open') { throw new Error('DataChannel not open during send'); }
                  const chunkView = value instanceof Uint8Array ? value : new Uint8Array(value);
                  for (let off = 0; off < chunkView.byteLength; off += SLICE) {
                    if (canceled) break;
                    if (channel.readyState !== 'open') { throw new Error('DataChannel not open during send'); }
                    const piece = chunkView.subarray(off, Math.min(off + SLICE, chunkView.byteLength));
                    await waitBufferedLow();
                    channel.send(piece);
                    sent += piece.byteLength;
                    const now = Date.now();
                    if (now - lastT >= 500) {
                      const db = sent - lastB; const dt = (now - lastT)/1000;
                      const speed = db/dt; const remain = Math.max(0, file.size - sent);
                      const eta = speed>0 ? remain/speed : 0;
                      prog.meta && (prog.meta.textContent = `${(speed/1024).toFixed(1)} KB/sï¼Œå‰©ä½™çº¦ ${eta.toFixed(1)} s`);
                      lastT = now; lastB = sent;
                    }
                    const pct = Math.min(100, Math.round((sent / file.size) * 100));
                    prog.bar.style.width = pct + '%';
                    if (sent % (512*1024) < SLICE) console.log('[send:progress]', toUserId, pct + '%');
                  }
                }
                if (!canceled) {
                  await waitBufferedLow();
                  channel.send(JSON.stringify({ type: 'file-end' }));
                  console.log('[send:file-end]', { to: toUserId, fileId });
                  prog.info.textContent = `å‘é€ç»™ ${toUserId}ï¼š${file.name}ï¼ˆå®Œæˆï¼‰`;
                  prog.bar.style.width = '100%';
                }
              } catch (err) {
                console.error('[p2p:send:error]', err);
                alert('P2P å‘é€å¤±è´¥ï¼š' + err.message);
              }
            }
          } catch {}
        } else {
          receiving.chunks.push(e.data);
          receiving.received += e.data.byteLength || 0;
          if (receiving.received % (512*1024) < 65536) console.log('[recv:progress]', toUserId, Math.round((receiving.received/receiving.size)*100)+'%');
          const key = `recv-${toUserId}-${receiving.name}`;
          if (progressMap[key]) {
            const pct = receiving.size ? Math.min(100, Math.round((receiving.received / receiving.size) * 100)) : 0;
            progressMap[key].bar.style.width = pct + '%';
          }
        }
      };
    }

    async function sendSignal(s) {
      if (!ws || ws.readyState !== WebSocket.OPEN) { console.warn('[signal] ws not open'); return; }
      const payload = { type: 'signal', data: { ...s, from: myUserId } };
      console.log('[signal:send]', payload);
      ws.send(JSON.stringify(payload));
    }

    async function connectToUser(toUserId) {
      console.log('[connect] to', toUserId);
      const pc = await createConnection(toUserId);
      const channel = pc.createDataChannel('chat');
      console.log('[dc:create]', toUserId, channel.label);
      registerDataChannel(toUserId, channel);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      sendSignal({ type: 'offer', to: toUserId, payload: { sdp: offer } });
    }

    async function handleSignalFromPeer(s) {
      const { type, from, payload } = s;
      console.log('[signal:recv]', type, 'from', from);
      const pc = await createConnection(from);
      if (type === 'offer') {
        await pc.setRemoteDescription(payload.sdp);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        sendSignal({ type: 'answer', to: from, payload: { sdp: answer } });
      } else if (type === 'answer') {
        await pc.setRemoteDescription(payload.sdp);
      } else if (type === 'candidate') {
        try { await pc.addIceCandidate(payload.candidate); } catch (e) { console.error(e); }
      }
    }

    const progressMap = {};

    function ensureProgress(div, key, label) {
      if (!progressMap[key]) {
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        const info = document.createElement('div');
        info.textContent = label;
        const meta = document.createElement('div');
        meta.className = 'small muted';
        meta.textContent = '';
        const progress = document.createElement('div');
        progress.className = 'progress';
        const bar = document.createElement('div');
        bar.className = 'bar';
        progress.appendChild(bar);
        const actions = document.createElement('div');
        actions.className = 'actions-row';
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'btn-sm';
        cancelBtn.textContent = 'å–æ¶ˆ';
        actions.appendChild(cancelBtn);
        bubble.appendChild(info);
        bubble.appendChild(meta);
        bubble.appendChild(progress);
        bubble.appendChild(actions);
        div.appendChild(bubble);
        progressMap[key] = { bar, info, meta, container: bubble, cancelBtn };
      }
      return progressMap[key];
    }

    function addMessageToUI(msg) {
      let chatBox;
      if (msg.private) {
        const otherUser = (msg.from === myUserId) ? (msg.to || '') : msg.from;
        if (!otherUser) return;
        ensurePrivateTab(otherUser);
        chatBox = document.getElementById('chatBox-' + otherUser);
      } else {
        chatBox = document.getElementById('chatBoxGroup');
      }

      if (msg.from === 'system') {
        const div = document.createElement('div');
        div.className = 'message system';
        div.textContent = msg.text;
        chatBox.appendChild(div);
        chatBox.scrollTop = chatBox.scrollHeight;
        return;
      }

      const isSelf = msg.from === myUserId;
      const div = document.createElement('div');
      div.className = isSelf ? 'message self' : 'message other';

      // è‹¥æä¾›ç›´æ¥çš„å†…å®¹èŠ‚ç‚¹ï¼ˆç”¨äº P2P æ–‡ä»¶å±•ç¤ºï¼‰
      if (msg.contentNode) {
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        bubble.appendChild(msg.contentNode);
        const header = document.createElement('div');
        header.className = 'header';
        const nameFrom = (msg.from === myUserId && displayName) ? displayName : msg.from;
        header.textContent = msg.private ? `${nameFrom}` : nameFrom;
        const timeEl = document.createElement('div');
        timeEl.className = 'time';
        timeEl.textContent = msg.time;
        div.appendChild(header);
        div.appendChild(bubble);
        div.appendChild(timeEl);
        chatBox.appendChild(div);
        chatBox.scrollTop = chatBox.scrollHeight;
        return;
      }

      // å°è¯•è§£ææ˜¯å¦ä¸ºæœåŠ¡å™¨æ–‡ä»¶æ¶ˆæ¯ æˆ– P2På ä½æ¶ˆæ¯
      let content;
      let isFile = false;
      try {
        const parsed = JSON.parse(msg.text);
        if (parsed && parsed.type === 'file') {
          isFile = true;
          const { url, name, size } = parsed;
          const ext = name.split('.').pop()?.toLowerCase() || '';

          const formatSize = (bytes) => {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
          };

          if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'].includes(ext)) {
            const img = document.createElement('img');
            img.src = `http://${serviceUrl}${url}`;
            img.alt = name;
            img.style.maxWidth = '100%';
            img.style.borderRadius = '8px';
            img.style.marginTop = '6px';
            img.style.cursor = 'pointer';
            img.onclick = () => window.open(img.src, '_blank');
            content = img;
          } else {
            const link = document.createElement('a');
            link.href = `http://${serviceUrl}${url}`;
            link.target = '_blank';
            link.textContent = `ğŸ“ ${name} (${formatSize(size)})`;
            link.style.color = isSelf ? 'white' : '#0084ff';
            link.style.textDecoration = 'underline';
            content = link;
          }
        } else if (parsed && parsed.type === 'p2p-file') {
          // ç¾¤é‡Œå ä½æ¡ç›®ï¼šç‚¹å‡»å†å»ºé“¾æ‹‰å– + æ˜¾ç¤ºå‘é€è€…ä¿¡æ¯
          const { fileId, name, size, from } = parsed;
          const wrap = document.createElement('div');
          const a = document.createElement('a');
          a.href = '#';
          a.textContent = `ğŸ“ ${name} (${(size/1024).toFixed(1)} KB) â€” ç‚¹å‡»ä¸‹è½½`;
          a.onclick = (ev) => {
            ev.preventDefault();
            // ä»…åœ¨â€œè‡ªå·±æ˜¯å‘é€è€…â€æ—¶æ£€æŸ¥æœ¬åœ°ç¼“å­˜ï¼›å…¶ä»–ç”¨æˆ·åº”å§‹ç»ˆå‘èµ·è¯·æ±‚ç»™å‘é€è€…
            if (from === myUserId) {
              if (!window.pendingFiles || !window.pendingFiles[fileId]) {
                alert('æ–‡ä»¶å·²å¤±æ•ˆï¼Œå‘é€è€…ç«¯æœªç¼“å­˜è¯¥æ–‡ä»¶');
                return;
              }
            }
            requestFile(from, fileId);
          };
          a.style.color = isSelf ? 'white' : '#0084ff';
          a.style.textDecoration = 'underline';
          const meta = document.createElement('div');
          meta.style.fontSize = '12px';
          meta.style.color = isSelf ? '#a0d4ff' : '#666';
          meta.textContent = `æ¥è‡ªç”¨æˆ·ï¼š${(from === myUserId && displayName) ? displayName : from}`;
          wrap.appendChild(a);
          wrap.appendChild(meta);
          content = wrap;
        }
      } catch (e) {
        // æ™®é€šæ–‡æœ¬
      }

      if (!isFile && !content) {
        const text = msg.private ? `ğŸ”’ ${msg.text}` : msg.text;
        content = document.createTextNode(text);
      }

      // æ¶ˆæ¯æ°”æ³¡
      const bubble = document.createElement('div');
      bubble.className = 'bubble';
      if (content instanceof Node) {
        bubble.appendChild(content);
      } else {
        bubble.textContent = content;
      }

      // ç”¨æˆ·å
      const header = document.createElement('div');
      header.className = 'header';
      const nameFrom = (msg.from === myUserId && displayName) ? displayName : msg.from;
      header.textContent = msg.private ? `${nameFrom}` : nameFrom;

      // æ—¶é—´
      const timeEl = document.createElement('div');
      timeEl.className = 'time';
      timeEl.textContent = msg.time;

      div.appendChild(header);
      div.appendChild(bubble);
      div.appendChild(timeEl);

      chatBox.appendChild(div);
      chatBox.scrollTop = chatBox.scrollHeight;

      // å­˜å…¥æœ¬åœ°å†å²å¹¶è£å‰ª
      try {
        const rec = { text: msg.text || '', from: msg.from, to: msg.to || '', time: msg.time || new Date().toLocaleTimeString(), private: !!msg.private };
        if (rec.private) {
          const other = (msg.from === myUserId) ? (msg.to || '') : msg.from;
          if (other) {
            historyStore.private[other] = historyStore.private[other] || [];
            historyStore.private[other].push(rec);
            if (historyStore.private[other].length > historyLimit) historyStore.private[other].splice(0, historyStore.private[other].length - historyLimit);
          }
        } else {
          historyStore.group.push(rec);
          if (historyStore.group.length > historyLimit) historyStore.group.splice(0, historyStore.group.length - historyLimit);
        }
        localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore));
      } catch (e) { console.warn('[history] save error', e); }
    }

    async function sendMessageScoped(isPrivate) {
      const input = isPrivate ? document.getElementById('messageInputPrivate') : document.getElementById('messageInputGroup');
      const btn = isPrivate ? document.getElementById('sendBtnPrivate') : document.getElementById('sendBtnGroup');
      const text = (input?.value || '').trim();
      if (!text) return;
      if (!myUserId) { console.warn('[send] myUserId æœªåˆå§‹åŒ–ï¼Œç¨åé‡è¯•'); alert('æ­£åœ¨è¿æ¥æœåŠ¡å™¨ï¼Œè¯·ç¨åå†è¯•'); return; }

      try {
        btn.disabled = true; btn.classList.add('disabled');
        let url, payload;
        if (isPrivate) {
          const to = (document.getElementById('targetUser')||{}).value || '';
          if (!to) { alert('è¯·é€‰æ‹©ç§èŠå¯¹è±¡'); return; }
          url = `http://${serviceUrl}/send/private`;
          payload = { message: text, from: myUserId, to };
        } else {
          url = `http://${serviceUrl}/send`;
          payload = { message: text, from: myUserId };
        }
        const res = await fetch(url, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        input.value = '';
      } catch (err) {
        console.error('[send:error]', err);
        alert('å‘é€å¤±è´¥ï¼Œè¯·é‡è¯•');
      } finally {
        btn.disabled = false; btn.classList.remove('disabled');
      }
    }
    window.sendMessageScoped = sendMessageScoped;

    function pickP2PUpload() {
      const input = document.getElementById('fileInput');
      input.onchange = () => uploadFileP2P();
      input.click();
    }
    window.pickP2PUpload = pickP2PUpload;

    function pickServerUpload() {
      const input = document.getElementById('fileInputServer');
      input.onchange = () => uploadFileServer();
      input.click();
    }
    window.pickServerUpload = pickServerUpload;

    // ç›´ä¼ ç»™æŒ‡å®šç”¨æˆ·ï¼ˆç«‹å³å»ºé“¾å¹¶å‘é€ï¼‰
    async function uploadFileDirect(targetUserId) {
      const input = document.getElementById('fileInputDirect');
      const file = input.files[0];
      if (!file || !myUserId) return;
      await connectToUser(targetUserId);
      await new Promise(res => { const check=()=>{ if (dataChannels[targetUserId]) res(); else setTimeout(check,200)}; check(); });
      const channel = dataChannels[targetUserId];
      try {
        await waitForIceConnected(peerConnections[targetUserId]);
        await waitForChannelOpen(channel);
      } catch (e) { console.error('[direct] open failed', e); alert('P2P è¿æ¥æœªå°±ç»ªï¼Œè¯·ç¨åå†è¯•'); return; }
      const container = document.createElement('div');
      container.className = 'message self';
      const prog = ensureProgress(container, `send-${targetUserId}-${Date.now()}`, `å‘é€ç»™ ${targetUserId}ï¼š${file.name}`);
      ensurePrivateTab(targetUserId);
      document.getElementById('chatBox-' + targetUserId).appendChild(container);
      if (channel.readyState !== 'open') { alert('P2P é€šé“æœªå°±ç»ª'); return; }
      try { channel.send(JSON.stringify({ type: 'file-meta', name: file.name, size: file.size, mime: file.type || 'application/octet-stream' })); } catch (e) { console.error('[direct] meta send failed', e); alert('P2P å…ƒä¿¡æ¯å‘é€å¤±è´¥'); return; }
      // åˆ†ç‰‡+é˜ˆå€¼é™æµï¼ˆå°åˆ†ç‰‡ + bufferedamountlowï¼‰
      const reader = file.stream().getReader();
      let sent = 0; const start = Date.now(); let lastT = start, lastB = 0; let canceled = false;
      const onClose = () => { canceled = true; prog.info.textContent = `è¿æ¥å·²å…³é—­ï¼š${file.name}`; };
      channel.addEventListener('close', onClose);
      const SLICE = 64 * 1024; // 64KB
      channel.bufferedAmountLowThreshold = 256 * 1024;
      const waitBufferedLow = async () => {
        if (channel.bufferedAmount <= channel.bufferedAmountLowThreshold) return;
        await new Promise(resolve => {
          const h = () => { channel.removeEventListener('bufferedamountlow', h); resolve(); };
          channel.addEventListener('bufferedamountlow', h);
        });
      };
      while (true) {
        const { done, value } = await reader.read();
        if (done || canceled) break;
        if (channel.readyState !== 'open') { console.warn('[direct] channel not open during send'); break; }
        const chunkView = value instanceof Uint8Array ? value : new Uint8Array(value);
        for (let off = 0; off < chunkView.byteLength; off += SLICE) {
          if (canceled) break;
          if (channel.readyState !== 'open') { console.warn('[direct] channel not open during send'); canceled = true; break; }
          const piece = chunkView.subarray(off, Math.min(off + SLICE, chunkView.byteLength));
          await waitBufferedLow();
          try { channel.send(piece); } catch (e) { console.error('[direct] chunk send failed', e); canceled = true; break; }
          sent += piece.byteLength;
          const now = Date.now();
          const dt = (now - lastT)/1000; const db = sent - lastB;
          if (dt >= 0.5) {
            const speed = db/dt; const remain = Math.max(0, file.size - sent);
            const eta = speed>0 ? remain/speed : 0;
            prog.meta.textContent = `${(speed/1024).toFixed(1)} KB/sï¼Œå‰©ä½™çº¦ ${eta.toFixed(1)} s`;
            lastT = now; lastB = sent;
          }
          prog.bar.style.width = Math.round((sent/file.size)*100) + '%';
        }
      }
      if (!canceled && channel.readyState === 'open') {
        await waitBufferedLow();
        try { channel.send(JSON.stringify({ type: 'file-end' })); } catch {}
        prog.info.textContent = `å‘é€ç»™ ${targetUserId}ï¼š${file.name}ï¼ˆå®Œæˆï¼‰`;
        prog.bar.style.width = '100%';
      }
      input.value = '';
      // å–æ¶ˆæ”¯æŒï¼šç‚¹å‡»å–æ¶ˆæŒ‰é’®ä¸­æ–­è¯»å–
      prog.cancelBtn.onclick = () => {
        try { reader.cancel(); } catch {}
        prog.info.textContent = `å·²å–æ¶ˆï¼š${file.name}`;
        prog.meta.textContent = '';
      };
    }

    // æ”¹ä¸ºä»…å¹¿æ’­æ–‡ä»¶å…ƒä¿¡æ¯ï¼Œå ä½ï¼›ç‚¹å‡»æ—¶å†å»ºç«‹è¿æ¥ä¼ è¾“ï¼ˆP2Pï¼‰
    async function uploadFileP2P() {
      const fileInput = document.getElementById('fileInput');
      const file = fileInput.files[0];
      if (!file || !myUserId) return;

      const fileId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      window.pendingFiles = window.pendingFiles || {};
      window.pendingFiles[fileId] = file; // å‘é€è€…æœ¬åœ°ç¼“å­˜

      // å‘ç¾¤é‡Œå¹¿æ’­å ä½æ¶ˆæ¯
      await fetch(`http://${serviceUrl}/send`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          message: JSON.stringify({ type: 'p2p-file', fileId, name: file.name, size: file.size, from: myUserId }),
          from: myUserId
        })
      });

      // è‡ªå·±æœ¬åœ°æ˜¾ç¤ºä¸€æ¡å ä½ï¼ˆç‚¹å‡»ä¹Ÿå¯ä»¥è‡ªæˆ‘ä¸‹è½½ï¼‰
      addMessageToUI({
        from: myUserId,
        time: new Date().toLocaleTimeString(),
        text: JSON.stringify({ type: 'p2p-file', fileId, name: file.name, size: file.size, from: myUserId })
      });

      fileInput.value = '';
    }

    // ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼ˆå¸¦è¿›åº¦æ¡ï¼‰
    async function uploadFileServer() {
      const input = document.getElementById('fileInputServer');
      const file = input.files[0];
      if (!file || !myUserId) return;

      // åœ¨è‡ªå·±çš„æ¶ˆæ¯åŒºæ’å…¥è¿›åº¦æ¡
      const container = document.createElement('div');
      container.className = 'message self';
      const prog = ensureProgress(container, `server-${Date.now()}-${file.name}`, `ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼š${file.name}`);
      // è‹¥å½“å‰åœ¨ç§èŠä¸Šä¸‹æ–‡ï¼Œå¯è€ƒè™‘å±•ç¤ºåœ¨å½“å‰æ´»åŠ¨çš„ç§èŠçª—å£ï¼Œå¦åˆ™é»˜è®¤ç¾¤èŠ
      const active = document.querySelector('.chatbox:not([style*="display: none"])');
      if (active && active.id && active.id.startsWith('chatBox-')) active.appendChild(container);
      else document.getElementById('chatBoxGroup').appendChild(container);

      const formData = new FormData();
      formData.append('file', file);

      // ä½¿ç”¨ XMLHttpRequest ä»¥ä¾¿è¿½è¸ªä¸Šä¼ è¿›åº¦
      await new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', `http://${serviceUrl}/upload`);
        xhr.upload.onprogress = (e) => {
          if (e.lengthComputable) {
            const pct = Math.min(100, Math.round((e.loaded / e.total) * 100));
            prog.bar.style.width = pct + '%';
          }
        };
        xhr.onload = () => {
          if (xhr.status >= 200 && xhr.status < 300) resolve(JSON.parse(xhr.responseText)); else reject(new Error(xhr.statusText));
        };
        xhr.onerror = reject;
        xhr.send(formData);
      }).then(async () => {
        // ä¸Šä¼ æˆåŠŸåï¼Œå¹¿æ’­æ–‡ä»¶é“¾æ¥æ¶ˆæ¯
        const res = await fetch(`http://${serviceUrl}/api/files`);
        const list = await res.json();
        const found = list.find(x => x.name === file.name) || null;
        if (found) {
          await fetch(`http://${serviceUrl}/send`, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              message: JSON.stringify({ type: 'file', url: found.url, name: found.name, size: found.size }),
              from: myUserId
            })
          });
          prog.info.textContent = `ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼š${file.name}ï¼ˆå®Œæˆï¼‰`;
          prog.bar.style.width = '100%';
        } else {
          prog.info.textContent = `ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼š${file.name}ï¼ˆæˆåŠŸï¼Œç´¢å¼•æœªæ‰¾åˆ°ï¼‰`;
        }
      }).catch(err => {
        console.error(err);
        prog.info.textContent = `ä¸Šä¼ åˆ°æœåŠ¡å™¨ï¼š${file.name}ï¼ˆå¤±è´¥ï¼‰`;
        console.error('[server:upload:error]', err);
      });

      input.value = '';
    }

    async function requestFile(fromUserId, fileId) {
      // å»ºç«‹åˆ°å‘é€è€…çš„è¿æ¥
      console.log('[requestFile] start', { fromUserId, fileId });
      await connectToUser(fromUserId);
      await new Promise(resolve => {
        const check = () => {
          if (dataChannels[fromUserId]) resolve();
          else setTimeout(check, 200);
        };
        check();
      });
      await waitForChannelOpen(dataChannels[fromUserId]);
      // å‘é€è¯·æ±‚
      console.log('[requestFile] send request', { to: fromUserId, fileId });
      dataChannels[fromUserId].send(JSON.stringify({ type: 'p2p-file-request', fileId }));
    }

    // å³ä¸Šè§’è®¾ç½®å¼¹çª—äº¤äº’
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const settingsClose = document.getElementById('settingsClose');
    settingsBtn.addEventListener('click', () => {
      settingsModal.style.display = 'flex';
      const sw=document.getElementById('lanModeSwitch'); if (sw) sw.checked = lanMode;
      const nickInput = document.getElementById('nickInput');
      const saveChk = document.getElementById('saveNickChk');
      if (nickInput) nickInput.value = displayName || '';
      if (saveChk) saveChk.checked = !!localStorage.getItem('nickname');
      const historyInput = document.getElementById('historyLimitInput');
      if (historyInput) historyInput.value = historyLimit;
    });
    settingsClose.addEventListener('click', () => { settingsModal.style.display = 'none'; });
    settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) settingsModal.style.display = 'none'; });

    // è®¾ç½®ï¼šLAN æ¨¡å¼å¼€å…³ / æ˜µç§°ä¿å­˜ / é‡ç½®èº«ä»½
    document.addEventListener('change', (e) => {
      if (e.target && e.target.id === 'lanModeSwitch') {
        lanMode = !!e.target.checked;
        console.log('[settings] lanMode =', lanMode);
      }
      if (e.target && e.target.id === 'saveNickChk') {
        const chk = e.target.checked;
        const val = (document.getElementById('nickInput')||{}).value || '';
        if (chk && val) {
          localStorage.setItem('nickname', val);
          displayName = val;
        } else if (!chk) {
          localStorage.removeItem('nickname');
        }
      }
    });

    // è®¾ç½®ï¼šèŠå¤©è®°å½•æ¡æ•°ä¿å­˜
    document.addEventListener('input', (e) => {
      if (e.target && e.target.id === 'historyLimitInput') {
        const v = Math.max(10, Math.min(10000, parseInt(e.target.value||'100',10)||100));
        historyLimit = v;
        localStorage.setItem(HISTORY_LIMIT_KEY, String(historyLimit));
        // å³åˆ»è£å‰ªå¹¶ä¿å­˜
        try {
          if (historyStore.group.length > historyLimit) historyStore.group.splice(0, historyStore.group.length - historyLimit);
          for (const k in historyStore.private) {
            const arr = historyStore.private[k] || [];
            if (arr.length > historyLimit) arr.splice(0, arr.length - historyLimit);
          }
          localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore));
        } catch (e2) { console.warn('[history] limit apply error', e2); }
      }
    });

    // å¯¼å‡º/å¯¼å…¥èŠå¤©è®°å½•
    document.addEventListener('click', async (e) => {
      if (e.target && e.target.id === 'exportHistoryBtn') {
        const blob = new Blob([JSON.stringify({ limit: historyLimit, ...historyStore }, null, 2)], { type:'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `go-chat-history-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      }
      if (e.target && e.target.id === 'importHistoryBtn') {
        const picker = document.createElement('input'); picker.type='file'; picker.accept='.json,application/json';
        picker.onchange = async () => {
          const f = picker.files && picker.files[0]; if (!f) return;
          try {
            const text = await f.text();
            const obj = JSON.parse(text);
            if (!obj || typeof obj !== 'object') throw new Error('bad json');
            const limit = parseInt(obj.limit || obj.historyLimit || historyLimit, 10) || historyLimit;
            const grp = Array.isArray(obj.group) ? obj.group : [];
            const prv = obj.private && typeof obj.private === 'object' ? obj.private : {};
            historyLimit = Math.max(10, Math.min(10000, limit));
            localStorage.setItem(HISTORY_LIMIT_KEY, String(historyLimit));
            historyStore = { group: grp.slice(-historyLimit), private: {} };
            for (const k in prv) historyStore.private[k] = (prv[k]||[]).slice(-historyLimit);
            localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore));
            alert('å¯¼å…¥æˆåŠŸï¼Œåˆ·æ–°é¡µé¢åç”Ÿæ•ˆï¼ˆç¾¤èŠè‡ªåŠ¨æ¸²æŸ“ï¼Œç§èŠåœ¨æ‰“å¼€å¯¹åº”ä¼šè¯æ—¶æ¸²æŸ“ï¼‰');
          } catch (err) { alert('å¯¼å…¥å¤±è´¥ï¼š' + err.message); }
        };
        picker.click();
      }
    });

    // é‡ç½®èº«ä»½ï¼šæ¸…é™¤æœ¬åœ° userId å¹¶é‡æ–°è¿æ¥
    document.addEventListener('click', (e) => {
      if (e.target && e.target.id === 'resetIdentityBtn') {
        try { localStorage.removeItem('userId'); } catch {}
        alert('å·²æ¸…é™¤æœ¬åœ°ç”¨æˆ·IDï¼Œå°†é‡æ–°è¿æ¥æœåŠ¡å™¨ä»¥è·å–æ–°çš„ID');
        try { if (ws) ws.close(); } catch {}
        // ç«‹å³é‡è¿ä»¥åˆ·æ–°èº«ä»½
        setTimeout(connectWebSocket, 300);
      }
    });

    // è®¾ç½®ï¼šèŠå¤©è®°å½•æ¡æ•°ä¿å­˜
    document.addEventListener('input', (e) => {
      if (e.target && e.target.id === 'historyLimitInput') {
        const v = Math.max(10, Math.min(10000, parseInt(e.target.value||'100',10)||100));
        historyLimit = v;
        localStorage.setItem(HISTORY_LIMIT_KEY, String(historyLimit));
        // å³åˆ»è£å‰ªå¹¶ä¿å­˜
        try {
          if (historyStore.group.length > historyLimit) historyStore.group.splice(0, historyStore.group.length - historyLimit);
          for (const k in historyStore.private) {
            const arr = historyStore.private[k] || [];
            if (arr.length > historyLimit) arr.splice(0, arr.length - historyLimit);
          }
          localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore));
        } catch (e2) { console.warn('[history] limit apply error', e2); }
      }
    });

    // å¯¼å‡º/å¯¼å…¥èŠå¤©è®°å½•
    document.addEventListener('click', async (e) => {
      if (e.target && e.target.id === 'exportHistoryBtn') {
        const blob = new Blob([JSON.stringify({ limit: historyLimit, ...historyStore }, null, 2)], { type:'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `go-chat-history-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      }
      if (e.target && e.target.id === 'importHistoryBtn') {
        const picker = document.createElement('input'); picker.type='file'; picker.accept='.json,application/json';
        picker.onchange = async () => {
          const f = picker.files && picker.files[0]; if (!f) return;
          try {
            const text = await f.text();
            const obj = JSON.parse(text);
            if (!obj || typeof obj !== 'object') throw new Error('bad json');
            const limit = parseInt(obj.limit || obj.historyLimit || historyLimit, 10) || historyLimit;
            const grp = Array.isArray(obj.group) ? obj.group : [];
            const prv = obj.private && typeof obj.private === 'object' ? obj.private : {};
            historyLimit = Math.max(10, Math.min(10000, limit));
            localStorage.setItem(HISTORY_LIMIT_KEY, String(historyLimit));
            historyStore = { group: grp.slice(-historyLimit), private: {} };
            for (const k in prv) historyStore.private[k] = (prv[k]||[]).slice(-historyLimit);
            localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore));
            alert('å¯¼å…¥æˆåŠŸï¼Œåˆ·æ–°é¡µé¢åç”Ÿæ•ˆï¼ˆç¾¤èŠè‡ªåŠ¨æ¸²æŸ“ï¼Œç§èŠåœ¨æ‰“å¼€å¯¹åº”ä¼šè¯æ—¶æ¸²æŸ“ï¼‰');
          } catch (err) { alert('å¯¼å…¥å¤±è´¥ï¼š' + err.message); }
        };
        picker.click();
      }
    });
    document.addEventListener('input', (e) => {
      if (e.target && e.target.id === 'nickInput') {
        const val = e.target.value.trim();
        displayName = val;
        // è‹¥å‹¾é€‰â€œä¿å­˜æ˜µç§°â€ï¼Œåˆ™å®æ—¶ä¿å­˜
        const save = document.getElementById('saveNickChk');
        if (save && save.checked) {
          if (val) localStorage.setItem('nickname', val);
          else localStorage.removeItem('nickname');
        }
      }
    });

    // è®¾ç½®ï¼šèŠå¤©è®°å½•æ¡æ•°ä¿å­˜
    document.addEventListener('input', (e) => {
      if (e.target && e.target.id === 'historyLimitInput') {
        const v = Math.max(10, Math.min(10000, parseInt(e.target.value||'100',10)||100));
        historyLimit = v;
        localStorage.setItem(HISTORY_LIMIT_KEY, String(historyLimit));
        // å³åˆ»è£å‰ªå¹¶ä¿å­˜
        try {
          if (historyStore.group.length > historyLimit) historyStore.group.splice(0, historyStore.group.length - historyLimit);
          for (const k in historyStore.private) {
            const arr = historyStore.private[k] || [];
            if (arr.length > historyLimit) arr.splice(0, arr.length - historyLimit);
          }
          localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore));
        } catch (e2) { console.warn('[history] limit apply error', e2); }
      }
    });

    // å¯¼å‡º/å¯¼å…¥èŠå¤©è®°å½•
    document.addEventListener('click', async (e) => {
      if (e.target && e.target.id === 'exportHistoryBtn') {
        const blob = new Blob([JSON.stringify({ limit: historyLimit, ...historyStore }, null, 2)], { type:'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `go-chat-history-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      }
      if (e.target && e.target.id === 'importHistoryBtn') {
        const picker = document.createElement('input'); picker.type='file'; picker.accept='.json,application/json';
        picker.onchange = async () => {
          const f = picker.files && picker.files[0]; if (!f) return;
          try {
            const text = await f.text();
            const obj = JSON.parse(text);
            if (!obj || typeof obj !== 'object') throw new Error('bad json');
            const limit = parseInt(obj.limit || obj.historyLimit || historyLimit, 10) || historyLimit;
            const grp = Array.isArray(obj.group) ? obj.group : [];
            const prv = obj.private && typeof obj.private === 'object' ? obj.private : {};
            historyLimit = Math.max(10, Math.min(10000, limit));
            localStorage.setItem(HISTORY_LIMIT_KEY, String(historyLimit));
            historyStore = { group: grp.slice(-historyLimit), private: {} };
            for (const k in prv) historyStore.private[k] = (prv[k]||[]).slice(-historyLimit);
            localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore));
            alert('å¯¼å…¥æˆåŠŸï¼Œåˆ·æ–°é¡µé¢åç”Ÿæ•ˆï¼ˆç¾¤èŠè‡ªåŠ¨æ¸²æŸ“ï¼Œç§èŠåœ¨æ‰“å¼€å¯¹åº”ä¼šè¯æ—¶æ¸²æŸ“ï¼‰');
          } catch (err) { alert('å¯¼å…¥å¤±è´¥ï¼š' + err.message); }
        };
        picker.click();
      }
    });

    // æµ‹è¯•æŒ‰é’®ç»‘å®š
    document.getElementById('testSendText').addEventListener('click', async () => {
      const text = 'Hello from settings panel';
      try {
        const res = await fetch(`http://${serviceUrl}/send`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: text, from: myUserId || 'PANEL_'+Date.now() }) });
        alert('å‘é€æ–‡æœ¬å®Œæˆ: ' + res.status);
      } catch (e) { alert('å‘é€å¤±è´¥: ' + e.message); }
    });
    document.getElementById('testPrivate').addEventListener('click', async () => {
      const to = (document.getElementById('targetUser')||{}).value || prompt('è¾“å…¥ç›®æ ‡ç”¨æˆ·ID');
      if (!to) return; if (!myUserId) return alert('WSæœªè¿æ¥');
      await fetch(`http://${serviceUrl}/send/private`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ message: 'Hello (private)', from: myUserId, to }) });
      alert('å·²å‘é€ç§èŠåˆ° ' + to);
    });

    document.getElementById('testWS').addEventListener('click', () => {
      try {
        const ws2 = new WebSocket(`ws://${serviceUrl}/ws`);
        ws2.onopen = () => alert('[WS] open');
        ws2.onerror = (e) => alert('[WS] error');
        ws2.onclose = () => console.log('[WS] close');
      } catch(e) { alert(e.message); }
    });
    document.getElementById('testP2PPlaceholder').addEventListener('click', async () => {
      const fileId = 'TESTFILE_' + Date.now();
      const name = 'dummy.jpg'; const size = 128*1024;
      await fetch(`http://${serviceUrl}/send`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: JSON.stringify({ type: 'p2p-file', fileId, name, size, from: myUserId }), from: myUserId }) });
      alert('å·²ç¾¤å‘å ä½: ' + fileId);
    });
    document.getElementById('testFilesList').addEventListener('click', async () => {
      const res = await fetch(`http://${serviceUrl}/api/files`); const list = await res.json();
      alert('files: ' + list.length);
      console.log('[files]', list);
    });
    document.getElementById('testUploadSmall').addEventListener('click', async () => {
      const file = new File([new Blob(['settings panel upload'])], 'panel.txt', { type:'text/plain' });
      const fd = new FormData(); fd.append('file', file);
      await new Promise((resolve,reject)=>{ const xhr=new XMLHttpRequest(); xhr.open('POST', `http://${serviceUrl}/upload`); xhr.onload=()=>{ (xhr.status>=200&&xhr.status<300)?resolve():reject(new Error(xhr.statusText)); }; xhr.onerror=reject; xhr.send(fd); });
      alert('ä¸Šä¼ å®Œæˆ');
    });
    document.getElementById('testSignal').addEventListener('click', () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) return alert('WSæœªè¿æ¥');
      const to = prompt('è¾“å…¥ç›®æ ‡ç”¨æˆ·ID'); if (!to) return;
      const payload = { type:'ping', from: myUserId, to, payload:{ ts: Date.now() } };
      ws.send(JSON.stringify({ type:'signal', data: payload }));
      alert('å·²å‘é€ä¿¡ä»¤åˆ° ' + to);
    });

    // äº‹ä»¶ç»‘å®šï¼ˆæ›¿ä»£å†…è” onclickï¼‰ï¼Œæ›´ç¨³å¥
    document.getElementById('sendBtnGroup').addEventListener('click', () => {
      try { sendMessageScoped(false); } catch (err) { console.error('[sendMessageScoped:error]', err); }
    });

    // æ‰“å¼€èœå•
    const fileSendMenu = document.getElementById('fileSendMenu');
    document.getElementById('fileSendBtnGroup').addEventListener('click', () => {
      openFileSendMenuFor('');
    });
    function openFileSendMenuFor(targetUserId) {
      const sel = document.getElementById('menuTargetUser');
      sel.innerHTML = '<option value="">è¯·é€‰æ‹©ç”¨æˆ·</option>';
      onlineUsers.forEach(u => { const opt = document.createElement('option'); opt.value = u; opt.textContent = u; sel.appendChild(opt); });
      // è‹¥ä¼ å…¥äº†ç›®æ ‡ç”¨æˆ·ï¼Œé¢„é€‰ä¹‹å¹¶å±•ç¤ºç›´ä¼ é€‰é¡¹
      if (targetUserId) {
        document.querySelector('input[name="sendMode"][value="direct"]').checked = true;
        document.getElementById('menuTargetWrap').style.display = 'block';
        sel.value = targetUserId;
      }
      fileSendMenu.style.display = 'block';
    }

    // èœå•äº¤äº’ï¼šåˆ‡æ¢ç›´ä¼ æ—¶æ˜¾ç¤ºç”¨æˆ·é€‰æ‹©
    fileSendMenu.addEventListener('change', (e) => {
      if (e.target.name === 'sendMode') {
        document.getElementById('menuTargetWrap').style.display = (e.target.value === 'direct') ? 'block' : 'none';
      }
    });

    // è®¾ç½®ï¼šèŠå¤©è®°å½•æ¡æ•°ä¿å­˜
    document.addEventListener('input', (e) => {
      if (e.target && e.target.id === 'historyLimitInput') {
        const v = Math.max(10, Math.min(10000, parseInt(e.target.value||'100',10)||100));
        historyLimit = v;
        localStorage.setItem(HISTORY_LIMIT_KEY, String(historyLimit));
        // å³åˆ»è£å‰ªå¹¶ä¿å­˜
        try {
          if (historyStore.group.length > historyLimit) historyStore.group.splice(0, historyStore.group.length - historyLimit);
          for (const k in historyStore.private) {
            const arr = historyStore.private[k] || [];
            if (arr.length > historyLimit) arr.splice(0, arr.length - historyLimit);
          }
          localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore));
        } catch (e2) { console.warn('[history] limit apply error', e2); }
      }
    });

    // å¯¼å‡º/å¯¼å…¥èŠå¤©è®°å½•
    document.addEventListener('click', async (e) => {
      if (e.target && e.target.id === 'exportHistoryBtn') {
        const blob = new Blob([JSON.stringify({ limit: historyLimit, ...historyStore }, null, 2)], { type:'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `go-chat-history-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      }
      if (e.target && e.target.id === 'importHistoryBtn') {
        const picker = document.createElement('input'); picker.type='file'; picker.accept='.json,application/json';
        picker.onchange = async () => {
          const f = picker.files && picker.files[0]; if (!f) return;
          try {
            const text = await f.text();
            const obj = JSON.parse(text);
            if (!obj || typeof obj !== 'object') throw new Error('bad json');
            const limit = parseInt(obj.limit || obj.historyLimit || historyLimit, 10) || historyLimit;
            const grp = Array.isArray(obj.group) ? obj.group : [];
            const prv = obj.private && typeof obj.private === 'object' ? obj.private : {};
            historyLimit = Math.max(10, Math.min(10000, limit));
            localStorage.setItem(HISTORY_LIMIT_KEY, String(historyLimit));
            historyStore = { group: grp.slice(-historyLimit), private: {} };
            for (const k in prv) historyStore.private[k] = (prv[k]||[]).slice(-historyLimit);
            localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore));
            alert('å¯¼å…¥æˆåŠŸï¼Œåˆ·æ–°é¡µé¢åç”Ÿæ•ˆï¼ˆç¾¤èŠè‡ªåŠ¨æ¸²æŸ“ï¼Œç§èŠåœ¨æ‰“å¼€å¯¹åº”ä¼šè¯æ—¶æ¸²æŸ“ï¼‰');
          } catch (err) { alert('å¯¼å…¥å¤±è´¥ï¼š' + err.message); }
        };
        picker.click();
      }
    });

    // èœå•å–æ¶ˆ
    document.getElementById('menuCancel').addEventListener('click', () => {
      fileSendMenu.style.display = 'none';
    });

    // èœå•ç¡®è®¤
    document.getElementById('menuConfirm').addEventListener('click', () => {
      const mode = [...fileSendMenu.querySelectorAll('input[name="sendMode"]')].find(r => r.checked)?.value;
      if (!mode) return;
      fileSendMenu.style.display = 'none';
      if (mode === 'p2p') pickP2PUpload();
      else if (mode === 'server') pickServerUpload();
      else if (mode === 'direct') {
        const target = document.getElementById('menuTargetUser').value;
        if (!target) { alert('è¯·é€‰æ‹©æ¥æ”¶ç”¨æˆ·'); return; }
        const input = document.getElementById('fileInputDirect');
        input.onchange = () => uploadFileDirect(target);
        input.click();
      }
    });

    // è®¾ç½®ï¼šèŠå¤©è®°å½•æ¡æ•°ä¿å­˜
    document.addEventListener('input', (e) => {
      if (e.target && e.target.id === 'historyLimitInput') {
        const v = Math.max(10, Math.min(10000, parseInt(e.target.value||'100',10)||100));
        historyLimit = v;
        localStorage.setItem(HISTORY_LIMIT_KEY, String(historyLimit));
        // å³åˆ»è£å‰ªå¹¶ä¿å­˜
        try {
          if (historyStore.group.length > historyLimit) historyStore.group.splice(0, historyStore.group.length - historyLimit);
          for (const k in historyStore.private) {
            const arr = historyStore.private[k] || [];
            if (arr.length > historyLimit) arr.splice(0, arr.length - historyLimit);
          }
          localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore));
        } catch (e2) { console.warn('[history] limit apply error', e2); }
      }
    });

    // å¯¼å‡º/å¯¼å…¥èŠå¤©è®°å½•
    document.addEventListener('click', async (e) => {
      if (e.target && e.target.id === 'exportHistoryBtn') {
        const blob = new Blob([JSON.stringify({ limit: historyLimit, ...historyStore }, null, 2)], { type:'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `go-chat-history-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      }
      if (e.target && e.target.id === 'importHistoryBtn') {
        const picker = document.createElement('input'); picker.type='file'; picker.accept='.json,application/json';
        picker.onchange = async () => {
          const f = picker.files && picker.files[0]; if (!f) return;
          try {
            const text = await f.text();
            const obj = JSON.parse(text);
            if (!obj || typeof obj !== 'object') throw new Error('bad json');
            const limit = parseInt(obj.limit || obj.historyLimit || historyLimit, 10) || historyLimit;
            const grp = Array.isArray(obj.group) ? obj.group : [];
            const prv = obj.private && typeof obj.private === 'object' ? obj.private : {};
            historyLimit = Math.max(10, Math.min(10000, limit));
            localStorage.setItem(HISTORY_LIMIT_KEY, String(historyLimit));
            historyStore = { group: grp.slice(-historyLimit), private: {} };
            for (const k in prv) historyStore.private[k] = (prv[k]||[]).slice(-historyLimit);
            localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore));
            alert('å¯¼å…¥æˆåŠŸï¼Œåˆ·æ–°é¡µé¢åç”Ÿæ•ˆï¼ˆç¾¤èŠè‡ªåŠ¨æ¸²æŸ“ï¼Œç§èŠåœ¨æ‰“å¼€å¯¹åº”ä¼šè¯æ—¶æ¸²æŸ“ï¼‰');
          } catch (err) { alert('å¯¼å…¥å¤±è´¥ï¼š' + err.message); }
        };
        picker.click();
      }
    });

    const msgGroup = document.getElementById('messageInputGroup');
    msgGroup.addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        try { sendMessageScoped(false); } catch (err) { console.error('[sendMessageScoped:error]', err); }
      }
    });

    // è®¾ç½®ï¼šèŠå¤©è®°å½•æ¡æ•°ä¿å­˜
    document.addEventListener('input', (e) => {
      if (e.target && e.target.id === 'historyLimitInput') {
        const v = Math.max(10, Math.min(10000, parseInt(e.target.value||'100',10)||100));
        historyLimit = v;
        localStorage.setItem(HISTORY_LIMIT_KEY, String(historyLimit));
        // å³åˆ»è£å‰ªå¹¶ä¿å­˜
        try {
          if (historyStore.group.length > historyLimit) historyStore.group.splice(0, historyStore.group.length - historyLimit);
          for (const k in historyStore.private) {
            const arr = historyStore.private[k] || [];
            if (arr.length > historyLimit) arr.splice(0, arr.length - historyLimit);
          }
          localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore));
        } catch (e2) { console.warn('[history] limit apply error', e2); }
      }
    });

    // å¯¼å‡º/å¯¼å…¥èŠå¤©è®°å½•
    document.addEventListener('click', async (e) => {
      if (e.target && e.target.id === 'exportHistoryBtn') {
        const blob = new Blob([JSON.stringify({ limit: historyLimit, ...historyStore }, null, 2)], { type:'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `go-chat-history-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      }
      if (e.target && e.target.id === 'importHistoryBtn') {
        const picker = document.createElement('input'); picker.type='file'; picker.accept='.json,application/json';
        picker.onchange = async () => {
          const f = picker.files && picker.files[0]; if (!f) return;
          try {
            const text = await f.text();
            const obj = JSON.parse(text);
            if (!obj || typeof obj !== 'object') throw new Error('bad json');
            const limit = parseInt(obj.limit || obj.historyLimit || historyLimit, 10) || historyLimit;
            const grp = Array.isArray(obj.group) ? obj.group : [];
            const prv = obj.private && typeof obj.private === 'object' ? obj.private : {};
            historyLimit = Math.max(10, Math.min(10000, limit));
            localStorage.setItem(HISTORY_LIMIT_KEY, String(historyLimit));
            historyStore = { group: grp.slice(-historyLimit), private: {} };
            for (const k in prv) historyStore.private[k] = (prv[k]||[]).slice(-historyLimit);
            localStorage.setItem(HISTORY_KEY, JSON.stringify(historyStore));
            alert('å¯¼å…¥æˆåŠŸï¼Œåˆ·æ–°é¡µé¢åç”Ÿæ•ˆï¼ˆç¾¤èŠè‡ªåŠ¨æ¸²æŸ“ï¼Œç§èŠåœ¨æ‰“å¼€å¯¹åº”ä¼šè¯æ—¶æ¸²æŸ“ï¼‰');
          } catch (err) { alert('å¯¼å…¥å¤±è´¥ï¼š' + err.message); }
        };
        picker.click();
      }
    });

    // ç§èŠæ¨¡å¼æŒ‡ç¤ºä¸åˆ‡æ¢
    // åŠ¨æ€ç§èŠè¾“å…¥æ¡†ç®¡ç†
    const privateInputsContainer = document.getElementById('privateInputsContainer');
    function ensurePrivateTab(userId) {
      const privateTabs = document.getElementById('privateTabs');
      const boxesPrivate = document.getElementById('chatBoxesPrivate');
      // æŒ‰é’®å­˜åœ¨åˆ™ç›´æ¥è¿”å›
      if ([...privateTabs.children].some(b => b.dataset.tabId === userId)) return;
      // åˆ›å»ºæŒ‰é’®ï¼ˆå¸¦å…³é—­ï¼‰
      const btn = document.createElement('button');
      btn.className = 'btn-sm';
      btn.dataset.tabId = userId;
      btn.style.background = '#eee';
      btn.style.color = '#333';
      btn.innerHTML = `${userId} <span style="margin-left:6px;">âœ•</span>`;
      btn.onclick = (e) => {
        if (e.target && e.target.tagName === 'SPAN') {
          // å…³é—­ï¼šç§»é™¤æŒ‰é’®/èŠå¤©æ¡†/è¾“å…¥åŒº
          const box = document.getElementById('chatBox-' + userId);
          const input = document.getElementById('inputArea-' + userId);
          if (box) box.remove(); if (input) input.remove(); btn.remove();
          setActiveTab('group');
        } else {
          setActiveTab(userId);
        }
      };
      privateTabs.appendChild(btn);
      // åˆ›å»ºèŠå¤©æ¡†
      const chatBox = document.createElement('div');
      chatBox.id = 'chatBox-' + userId;
      chatBox.className = 'chatbox';
      chatBox.style.display = 'none';
      boxesPrivate.appendChild(chatBox);
      // åˆ›å»ºè¾“å…¥åŒº
      const inputArea = document.createElement('div');
      inputArea.id = 'inputArea-' + userId;
      inputArea.className = 'inputArea';
      inputArea.style.display = 'none';
      const input = document.createElement('input'); input.type = 'text'; input.placeholder = `å¯¹ ${userId} è¯´ç‚¹ä»€ä¹ˆ...`; input.autocomplete='off'; input.id = 'messageInput-' + userId; input.style.flex='1'; input.style.padding='14px 18px'; input.style.border='1px solid #ccc'; input.style.borderRadius='24px'; input.style.fontSize='16px';
      const sendBtn = document.createElement('button'); sendBtn.textContent = 'å‘é€'; sendBtn.id = 'sendBtn-' + userId;
      sendBtn.onclick = () => sendMessageTo(userId, input);
      const fileBtn = document.createElement('button'); fileBtn.textContent = 'ğŸ“ æ–‡ä»¶å‘é€'; fileBtn.onclick = () => openFileSendMenuFor(userId);
      inputArea.appendChild(input); inputArea.appendChild(sendBtn); inputArea.appendChild(fileBtn);
      boxesPrivate.appendChild(inputArea);
      // å›è½¦å‘é€
      input.addEventListener('keypress', (e) => { if (e.key==='Enter' && !e.shiftKey) { e.preventDefault(); sendBtn.click(); } });
    }

    function openPrivateChat(userId) {
      ensurePrivateTab(userId);
      setActiveTab(userId);
      const input = document.getElementById('messageInput-' + userId); input && input.focus();
      const box = document.getElementById('chatBox-' + userId);
      if (box) {
        // é¦–æ¬¡æ‰“å¼€æ—¶æ¸²æŸ“æœ¬åœ°å†å²
        if (!box.dataset.inited) {
          box.dataset.inited = '1';
          const list = (historyStore.private[userId] || []).slice(-historyLimit);
          list.forEach(r => addMessageToUI({ text: r.text, from: r.from, to: r.to, time: r.time, private: true }));
        }
        box.scrollTop = box.scrollHeight;
      }
    }
    window.openPrivateChat = openPrivateChat;

    function sendMessageTo(toUserId, inputEl) {
      const text = (inputEl?.value || '').trim();
      if (!text || !myUserId) return;
      fetch(`http://${serviceUrl}/send/private`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ message:text, from: myUserId, to: toUserId }) })
        .then(res => { if (!res.ok) throw new Error('HTTP '+res.status); inputEl.value=''; })
        .catch(err => { console.error('[send:private:error]', err); alert('å‘é€å¤±è´¥'); });
    }

    // åœ¨çº¿ç”¨æˆ·ä¸‹æ‹‰åˆ·æ–°ï¼ˆå…¼å®¹å­˜åœ¨ä¸å¦ï¼‰
    function refreshTargetUser() {
      const ids = ['menuTargetUser', 'targetUser'];
      ids.forEach(id => {
        const sel = document.getElementById(id);
        if (!sel) return;
        const keep = sel.value;
        // æ ¹æ®ä¸åŒä¸‹æ‹‰å±•ç¤ºä¸åŒé»˜è®¤é¡¹
        if (id === 'menuTargetUser') {
          sel.innerHTML = '<option value="">è¯·é€‰æ‹©ç”¨æˆ·</option>';
        } else {
          sel.innerHTML = '<option value="">ç¾¤èŠï¼ˆé»˜è®¤ï¼‰</option>';
        }
        onlineUsers.forEach(u => {
          const opt = document.createElement('option');
          opt.value = u; opt.textContent = u;
          sel.appendChild(opt);
        });
        if ([...sel.options].some(o => o.value === keep)) sel.value = keep;
      });
    }

    function renderOnlineUsers() {
      const listEl = document.getElementById('onlineList');
      const cntEl = document.getElementById('onlineCount');
      if (!listEl || !cntEl) return;
      listEl.innerHTML = '';
      cntEl.textContent = onlineUsers.length;
      onlineUsers.forEach(u => {
        const row = document.createElement('div');
        row.className = 'item';
        const idEl = document.createElement('div');
        idEl.className = 'id';
        idEl.textContent = u;
        const ops = document.createElement('div');
        ops.className = 'ops';
        const btnChat = document.createElement('button'); btnChat.textContent = 'ç§èŠ'; btnChat.onclick = () => openPrivateChat(u);
        const btnConn = document.createElement('button'); btnConn.textContent = 'ç›´è¿'; btnConn.onclick = () => connectToUser(u);
        const btnCopy = document.createElement('button'); btnCopy.textContent = 'å¤åˆ¶'; btnCopy.onclick = async () => { try { await navigator.clipboard.writeText(u); btnCopy.textContent='å·²å¤åˆ¶'; setTimeout(()=>btnCopy.textContent='å¤åˆ¶',1000);} catch(e){ alert('å¤åˆ¶å¤±è´¥'); } };
        ops.appendChild(btnChat); ops.appendChild(btnConn); ops.appendChild(btnCopy);
        row.appendChild(idEl); row.appendChild(ops);
        listEl.appendChild(row);
      });
    }

    document.getElementById('refreshUsers').addEventListener('click', () => renderOnlineUsers());

    // ä¾§è¾¹æ æ”¶èµ·/å±•å¼€
    (function(){
      const panel = document.getElementById('onlinePanel');
      const hd = panel.querySelector('.hd');
      const closeBtn = document.createElement('button');
      closeBtn.className = 'btn-sm';
      closeBtn.style.background = '#eee';
      closeBtn.style.color = '#333';
      closeBtn.textContent = 'å…³é—­é¢æ¿';
      closeBtn.onclick = () => {
        document.getElementById('onlinePanel').style.display = 'none';
        const icon = document.getElementById('onlineToggle'); if (icon) icon.style.display = 'block';
      };
      hd.appendChild(closeBtn);
      const icon = document.getElementById('onlineToggle');
      if (icon) icon.onclick = () => { document.getElementById('onlinePanel').style.display = 'block'; icon.style.display = 'none'; };
      // é»˜è®¤æ˜¾ç¤ºåˆ—è¡¨
      document.getElementById('onlineList').style.display = 'block';
    })();

    // èŠå¤©çª—åˆ‡æ¢
    (function(){
      const tabGroup = document.getElementById('tabGroup');
      const privateTabs = document.getElementById('privateTabs');
      const boxGroup = document.getElementById('chatBoxGroup');
      const boxesPrivate = document.getElementById('chatBoxesPrivate');

      function setActiveTab(tabId) {
        const isGroup = tabId === 'group';
        // æ˜¾ç¤º/éšè—ç¾¤èŠ
        boxGroup.style.display = isGroup ? 'flex' : 'none';
        document.getElementById('inputAreaGroup').style.display = isGroup ? 'flex' : 'none';
        // ç§èŠå®¹å™¨
        boxesPrivate.style.display = isGroup ? 'none' : 'block';
        document.getElementById('privateInputs').style.display = isGroup ? 'none' : 'flex';
        // åˆ‡æ¢æŒ‰é’®æ ·å¼
        tabGroup.style.background = isGroup ? '#0084ff' : '#eee';
        tabGroup.style.color = isGroup ? '#fff' : '#333';
        [...privateTabs.children].forEach(btn => {
          const active = btn.dataset.tabId === tabId;
          btn.style.background = active ? '#0084ff' : '#eee';
          btn.style.color = active ? '#fff' : '#333';
          const box = document.getElementById('chatBox-' + btn.dataset.tabId);
          const input = document.getElementById('inputArea-' + btn.dataset.tabId);
          if (box) {
            box.style.display = active ? 'flex' : 'none';
            if (active) box.scrollTop = box.scrollHeight;
          }
          if (input) {
            input.style.display = active ? 'flex' : 'none';
            if (active) {
              const inp = document.getElementById('messageInput-' + btn.dataset.tabId);
              inp && inp.focus();
            }
          }
        });
      }
      window.setActiveTab = setActiveTab;

      tabGroup.onclick = () => setActiveTab('group');
      setActiveTab('group');
    })();

    connectWebSocket();
    // åˆå§‹æ¸²æŸ“ï¼ˆå¦‚æœæœ‰ç¼“å­˜/å»¶è¿Ÿå¹¿æ’­ï¼‰
    renderOnlineUsers();

  </script>
</body>
</html>
